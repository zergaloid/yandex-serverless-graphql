"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRequest = exports.validateDocument = void 0;
const graphql_1 = require("graphql");
const util_1 = require("./util");
const errors_1 = require("./errors");
const parseQuery = (query, parse) => {
    if (typeof query !== "string" && query.kind === "Document") {
        return query;
    }
    try {
        const parseResult = parse(query);
        if (parseResult instanceof Promise) {
            return parseResult.catch((syntaxError) => {
                throw new errors_1.HttpError(400, "GraphQL syntax error.", {
                    graphqlErrors: [syntaxError],
                });
            });
        }
        return parseResult;
    }
    catch (syntaxError) {
        throw new errors_1.HttpError(400, "GraphQL syntax error.", {
            graphqlErrors: [syntaxError],
        });
    }
};
const validateDocument = (schema, document, validate, validationRules) => {
    const validationErrors = validate(schema, document, validationRules);
    if (validationErrors.length) {
        throw new errors_1.HttpError(400, "GraphQL validation error.", {
            graphqlErrors: validationErrors,
        });
    }
};
exports.validateDocument = validateDocument;
const getExecutableOperation = (document, operationName) => {
    const operation = (0, graphql_1.getOperationAST)(document, operationName);
    if (!operation) {
        throw new errors_1.HttpError(400, "Could not determine what operation to execute.");
    }
    return operation;
};
const processRequest = async (options) => {
    const { contextFactory, execute = graphql_1.execute, formatPayload = ({ payload }) => payload, operationName, parse = graphql_1.parse, query, request, rootValueFactory, schema, subscribe = graphql_1.subscribe, validate = graphql_1.validate, validationRules, variables, } = options;
    let context;
    let rootValue;
    let document;
    let operation;
    const result = await (async () => {
        const accept = typeof request.headers.get === "function" ? request.headers.get("accept") : request.headers.accept;
        const isEventStream = accept === "text/event-stream";
        try {
            if (!(0, util_1.isHttpMethod)("GET", request.method) && !(0, util_1.isHttpMethod)("POST", request.method)) {
                throw new errors_1.HttpError(405, "GraphQL only supports GET and POST requests.", {
                    headers: [{ name: "Allow", value: "GET, POST" }],
                });
            }
            if (query == null) {
                throw new errors_1.HttpError(400, "Must provide query string.");
            }
            document = await parseQuery(query, parse);
            (0, exports.validateDocument)(schema, document, validate, validationRules);
            operation = getExecutableOperation(document, operationName);
            if (operation.operation === "mutation" && (0, util_1.isHttpMethod)("GET", request.method)) {
                throw new errors_1.HttpError(405, "Can only perform a mutation operation from a POST request.", {
                    headers: [{ name: "Allow", value: "POST" }],
                });
            }
            let variableValues;
            try {
                if (variables) {
                    variableValues = typeof variables === "string" ? JSON.parse(variables) : variables;
                }
            }
            catch (_error) {
                throw new errors_1.HttpError(400, "Variables are invalid JSON.");
            }
            try {
                const executionContext = {
                    request,
                    document,
                    operation,
                    variables: variableValues,
                };
                context = contextFactory ? await contextFactory(executionContext) : {};
                rootValue = rootValueFactory ? await rootValueFactory(executionContext) : {};
                if (operation.operation === "subscription") {
                    const result = await subscribe(schema, document, rootValue, context, variableValues, operationName);
                    // If errors are encountered while subscribing to the operation, an execution result
                    // instead of an AsyncIterable.
                    if ((0, util_1.isAsyncIterable)(result)) {
                        return {
                            type: "PUSH",
                            subscribe: async (onResult) => {
                                for await (const payload of result) {
                                    onResult(formatPayload({
                                        payload,
                                        context,
                                        rootValue,
                                        document,
                                        operation,
                                    }));
                                }
                            },
                            unsubscribe: () => {
                                (0, util_1.stopAsyncIteration)(result);
                            },
                        };
                    }
                    else {
                        if (isEventStream) {
                            return {
                                type: "PUSH",
                                subscribe: async (onResult) => {
                                    onResult(formatPayload({
                                        payload: result,
                                        context,
                                        rootValue,
                                        document,
                                        operation,
                                    }));
                                },
                                unsubscribe: () => undefined,
                            };
                        }
                        else {
                            return {
                                type: "RESPONSE",
                                payload: formatPayload({
                                    payload: result,
                                    context,
                                    rootValue,
                                    document,
                                    operation,
                                }),
                                status: 200,
                                headers: [],
                            };
                        }
                    }
                }
                else {
                    const result = await execute(schema, document, rootValue, context, variableValues, operationName);
                    // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
                    // execution result.
                    if ((0, util_1.isAsyncIterable)(result)) {
                        return {
                            type: isEventStream ? "PUSH" : "MULTIPART_RESPONSE",
                            subscribe: async (onResult) => {
                                for await (const payload of result) {
                                    onResult(formatPayload({
                                        payload,
                                        context,
                                        rootValue,
                                        document,
                                        operation,
                                    }));
                                }
                            },
                            unsubscribe: () => {
                                (0, util_1.stopAsyncIteration)(result);
                            },
                        };
                    }
                    else {
                        return {
                            type: "RESPONSE",
                            status: 200,
                            headers: [],
                            payload: formatPayload({
                                payload: result,
                                context,
                                rootValue,
                                document,
                                operation,
                            }),
                        };
                    }
                }
            }
            catch (executionError) {
                if (executionError instanceof graphql_1.GraphQLError) {
                    throw new errors_1.HttpError(200, "GraphQLError encountered white executed GraphQL request.", {
                        graphqlErrors: [executionError],
                    });
                }
                else if (executionError instanceof errors_1.HttpError) {
                    throw executionError;
                }
                else {
                    throw new errors_1.HttpError(500, "Unexpected error encountered while executing GraphQL request.", {
                        graphqlErrors: [new graphql_1.GraphQLError(executionError.message)],
                    });
                }
            }
        }
        catch (error) {
            const payload = {
                errors: error.graphqlErrors || [new graphql_1.GraphQLError(error.message)],
            };
            if (isEventStream) {
                return {
                    type: "PUSH",
                    subscribe: async (onResult) => {
                        onResult(formatPayload({
                            payload,
                            context,
                            rootValue,
                            document,
                            operation,
                        }));
                    },
                    unsubscribe: () => undefined,
                };
            }
            else {
                return {
                    type: "RESPONSE",
                    status: error.status || 500,
                    headers: error.headers || [],
                    payload: formatPayload({
                        payload,
                        context,
                        rootValue,
                        document,
                        operation,
                    }),
                };
            }
        }
    })();
    return {
        ...result,
        context,
        rootValue,
        document,
        operation,
    };
};
exports.processRequest = processRequest;
