// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../index.js';

import * as protobuf from '../../../contrib/google/protobuf';
import * as operation from '../../../api/operation';
import * as NetworkLoadBalancer from '../../../NetworkLoadBalancer';
import * as Listener from '../../../Listener';

/**
 * A HealthCheck resource. For more information, see [Health check](/docs/load-balancer/concepts/health-check).
 */
export interface HealthCheck {
    /**
     * Name of the health check. The name must be unique for each target group that attached to a single load balancer. 3-63 characters long.
     */
    name: string;

    /**
     * The interval between health checks. The default is 2 seconds.
     */
    interval?: protobuf.Duration;

    /**
     * Timeout for a target to return a response for the health check. The default is 1 second.
     */
    timeout?: protobuf.Duration;

    /**
     * Number of failed health checks before changing the status to `` UNHEALTHY ``. The default is 2.
     */
    unhealthyThreshold?: Long;

    /**
     * Number of successful health checks required in order to set the `` HEALTHY `` status for the target. The default is 2.
     */
    healthyThreshold?: Long;

    /**
     * Options for TCP health check.
     */
    tcpOptions?: HealthCheck.TcpOptions;

    /**
     * Options for HTTP health check.
     */
    httpOptions?: HealthCheck.HttpOptions;
}

export namespace HealthCheck {
    /**
     * Configuration option for a TCP health check.
     */
    export interface TcpOptions {
        /**
         * Port to use for TCP health checks.
         */
        port?: Long;
    }

    /**
     * Configuration option for an HTTP health check.
     */
    export interface HttpOptions {
        /**
         * Port to use for HTTP health checks.
         */
        port?: Long;

        /**
         * URL path to set for health checking requests for every target in the target group.
         * For example `` /ping ``. The default path is `` / ``.
         */
        path?: string;
    }
}

/**
 * IP version of the addresses that the load balancer works with.
 * Only IPv4 is currently available.
 */
export enum IpVersion {
    IP_VERSION_UNSPECIFIED = 0,

    /**
     * IPv4
     */
    IPV4 = 1,

    /**
     * IPv6
     */
    IPV6 = 2,
}

/**
 * A NetworkLoadBalancer resource. For more information, see [Network Load Balancer](/docs/load-balancer/concepts).
 */
export interface NetworkLoadBalancer {
    /**
     * ID of the network load balancer.
     */
    id?: string;

    /**
     * ID of the folder that the network load balancer belongs to.
     */
    folderId?: string;

    /**
     * Creation timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the network load balancer. The name is unique within the folder. 3-63 characters long.
     */
    name?: string;

    /**
     * Optional description of the network load balancer. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs. Ðœaximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the region that the network load balancer belongs to.
     */
    regionId?: string;

    /**
     * Status of the network load balancer.
     */
    status?: NetworkLoadBalancer.Status;

    /**
     * Type of the network load balancer. Only external network load balancers are available now.
     */
    type?: NetworkLoadBalancer.Type;

    /**
     * Type of the session affinity. Only 5-tuple affinity is available now.
     */
    sessionAffinity?: NetworkLoadBalancer.SessionAffinity;

    /**
     * List of listeners for the network load balancer.
     */
    listeners?: Listener[];

    /**
     * List of target groups attached to the network load balancer.
     */
    attachedTargetGroups?: AttachedTargetGroup[];
}

export namespace NetworkLoadBalancer {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Network load balancer is being created.
         */
        CREATING = 1,

        /**
         * Network load balancer is being started.
         */
        STARTING = 2,

        /**
         * Network load balancer is active and sends traffic to the targets.
         */
        ACTIVE = 3,

        /**
         * Network load balancer is being stopped.
         */
        STOPPING = 4,

        /**
         * Network load balancer is stopped and doesn't send traffic to the targets.
         */
        STOPPED = 5,

        /**
         * Network load balancer is being deleted.
         */
        DELETING = 6,

        /**
         * The load balancer doesn't have any listeners or target groups, or
         * attached target groups are empty. The load balancer doesn't perform any health checks or
         * send traffic in this state.
         */
        INACTIVE = 7,
    }

    /**
     * Type of the load balancer. Only external load balancers are currently available.
     */
    export enum Type {
        TYPE_UNSPECIFIED = 0,

        /**
         * External network load balancer.
         */
        EXTERNAL = 1,

        /**
         * Internal network load balancer.
         */
        INTERNAL = 2,
    }

    /**
     * Type of session affinity. Only 5-tuple affinity is currently available.
     * For more information, see [Load Balancer concepts](/load-balancer/concepts/).
     */
    export enum SessionAffinity {
        SESSION_AFFINITY_UNSPECIFIED = 0,

        /**
         * 5-tuple affinity.
         */
        CLIENT_IP_PORT_PROTO = 1,
    }
}

/**
 * An AttachedTargetGroup resource. For more information, see [Targets and groups](/docs/load-balancer/concepts/target-resources).
 */
export interface AttachedTargetGroup {
    /**
     * ID of the target group.
     */
    targetGroupId: string;

    /**
     * A health check to perform on the target group.
     * For now we accept only one health check per AttachedTargetGroup.
     */
    healthChecks?: HealthCheck[];
}

/**
 * A Listener resource. For more information, see [Listener](/docs/load-balancer/concepts/listener)
 */
export interface Listener {
    /**
     * Name of the listener. The name must be unique for each listener on a single load balancer. 3-63 characters long.
     */
    name?: string;

    /**
     * IP address for the listener.
     */
    address?: string;

    /**
     * Port.
     */
    port?: Long;

    /**
     * Network protocol for incoming traffic.
     */
    protocol?: Listener.Protocol;

    /**
     * Port of a target.
     */
    targetPort?: Long;

    /**
     * ID of the subnet.
     */
    subnetId?: string;
}

export namespace Listener {
    /**
     * Network protocol to use.
     */
    export enum Protocol {
        PROTOCOL_UNSPECIFIED = 0,

        TCP = 1,

        UDP = 2,
    }
}

/**
 * State of the target that was returned after the last health check.
 */
export interface TargetState {
    /**
     * ID of the subnet that the target is connected to.
     */
    subnetId?: string;

    /**
     * IP address of the target.
     */
    address?: string;

    /**
     * Status of the target.
     */
    status?: TargetState.Status;
}

export namespace TargetState {
    /**
     * Status of the target.
     */
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * The network load balancer is setting up health checks for this target.
         */
        INITIAL = 1,

        /**
         * Health check passed and the target is ready to receive traffic.
         */
        HEALTHY = 2,

        /**
         * Health check failed and the target is not receiving traffic.
         */
        UNHEALTHY = 3,

        /**
         * Target is being deleted and the network load balancer is no longer sending traffic to this target.
         */
        DRAINING = 4,

        /**
         * The network load balancer is stopped and not performing health checks on this target.
         */
        INACTIVE = 5,
    }
}

/**
 * A set of methods for managing NetworkLoadBalancer resources.
 */
export class NetworkLoadBalancerService {
    constructor(session?: Session);
    /**
     * Returns the specified NetworkLoadBalancer resource.
     *
     * Get the list of available NetworkLoadBalancer resources by making a [List] request.
     */
    get(request: GetNetworkLoadBalancerRequest): Promise<NetworkLoadBalancer>;

    /**
     * Retrieves the list of NetworkLoadBalancer resources in the specified folder.
     */
    list(
        request: ListNetworkLoadBalancersRequest
    ): Promise<ListNetworkLoadBalancersResponse>;

    /**
     * Creates a network load balancer in the specified folder using the data specified in the request.
     */
    create(
        request: CreateNetworkLoadBalancerRequest
    ): Promise<operation.Operation>;

    /**
     * Updates the specified network load balancer.
     */
    update(
        request: UpdateNetworkLoadBalancerRequest
    ): Promise<operation.Operation>;

    /**
     * Deletes the specified network load balancer.
     */
    delete(
        request: DeleteNetworkLoadBalancerRequest
    ): Promise<operation.Operation>;

    /**
     * Starts load balancing and health checking with the specified network load balancer with specified settings.
     * Changes network load balancer status to `` ACTIVE ``.
     */
    start(
        request: StartNetworkLoadBalancerRequest
    ): Promise<operation.Operation>;

    /**
     * Stops load balancing and health checking with the specified network load balancer.
     * Changes load balancer status to `` STOPPED ``.
     */
    stop(request: StopNetworkLoadBalancerRequest): Promise<operation.Operation>;

    /**
     * Attaches a target group to the specified network load balancer.
     */
    attachTargetGroup(
        request: AttachNetworkLoadBalancerTargetGroupRequest
    ): Promise<operation.Operation>;

    /**
     * Detaches the target group from the specified network load balancer.
     */
    detachTargetGroup(
        request: DetachNetworkLoadBalancerTargetGroupRequest
    ): Promise<operation.Operation>;

    /**
     * Gets states of target resources in the attached target group.
     */
    getTargetStates(
        request: GetTargetStatesRequest
    ): Promise<GetTargetStatesResponse>;

    /**
     * Adds a listener to the specified network load balancer.
     */
    addListener(
        request: AddNetworkLoadBalancerListenerRequest
    ): Promise<operation.Operation>;

    /**
     * Removes the listener from the specified network load balancer.
     */
    removeListener(
        request: RemoveNetworkLoadBalancerListenerRequest
    ): Promise<operation.Operation>;

    /**
     * Lists operations for the specified network load balancer.
     */
    listOperations(
        request: ListNetworkLoadBalancerOperationsRequest
    ): Promise<ListNetworkLoadBalancerOperationsResponse>;
}

export interface GetNetworkLoadBalancerRequest {
    /**
     * ID of the NetworkLoadBalancer resource to return.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId?: string;
}

export interface ListNetworkLoadBalancersRequest {
    /**
     * ID of the folder that the network load balancer belongs to.
     * To get the folder ID, use a [NetworkLoadBalancerService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [<ResponseMessage>.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListNetworkLoadBalancersResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can only filter by the [NetworkLoadBalancer.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, or `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z][-a-z0-9]{1,61}[a-z0-9]$`.
     */
    filter?: string;
}

export interface ListNetworkLoadBalancersResponse {
    /**
     * List of NetworkLoadBalancer resources.
     */
    networkLoadBalancers?: NetworkLoadBalancer[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListNetworkLoadBalancersRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListNetworkLoadBalancersRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateNetworkLoadBalancerRequest {
    /**
     * ID of the folder to create a network load balancer in.
     * To get the folder ID, use a [NetworkLoadBalancerService.List] request.
     */
    folderId: string;

    /**
     * Name of the network load balancer.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the network load balancer.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the region where the network load balancer resides.
     */
    regionId: string;

    /**
     * Type of the network load balancer. Only external network load balancers are currently available.
     */
    type: NetworkLoadBalancer.Type;

    /**
     * List of listeners and their specs for the network load balancer.
     */
    listenerSpecs?: ListenerSpec[];

    /**
     * List of attached target groups for the network load balancer.
     */
    attachedTargetGroups?: AttachedTargetGroup[];
}

export interface CreateNetworkLoadBalancerMetadata {
    /**
     * ID of the network load balancer that is being created.
     */
    networkLoadBalancerId?: string;
}

export interface UpdateNetworkLoadBalancerRequest {
    /**
     * ID of the network load balancer to update.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;

    /**
     * Field mask that specifies which fields of the NetworkLoadBalancer resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the network load balancer.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the network load balancer.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs.
     *
     * The existing set of `` labels `` is completely replaced with the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * A list of listeners and their specs for the network load balancer.
     */
    listenerSpecs?: ListenerSpec[];

    /**
     * A list of attached target groups for the network load balancer.
     */
    attachedTargetGroups?: AttachedTargetGroup[];
}

export interface UpdateNetworkLoadBalancerMetadata {
    /**
     * ID of the NetworkLoadBalancer resource that is being updated.
     */
    networkLoadBalancerId?: string;
}

export interface DeleteNetworkLoadBalancerRequest {
    /**
     * ID of the network load balancer to delete.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;
}

export interface DeleteNetworkLoadBalancerMetadata {
    /**
     * ID of the NetworkLoadBalancer resource that is being deleted.
     */
    networkLoadBalancerId?: string;
}

export interface StartNetworkLoadBalancerRequest {
    /**
     * ID of the network load balancer to start.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;
}

export interface StartNetworkLoadBalancerMetadata {
    /**
     * ID of the NetworkLoadBalancer resource that is being started.
     */
    networkLoadBalancerId?: string;
}

export interface StopNetworkLoadBalancerRequest {
    /**
     * ID of the network load balancer to stop.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;
}

export interface StopNetworkLoadBalancerMetadata {
    /**
     * ID of the NetworkLoadBalancer resource that is being stopped.
     */
    networkLoadBalancerId?: string;
}

export interface AttachNetworkLoadBalancerTargetGroupRequest {
    /**
     * ID of the network load balancer to attach the target group to.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;

    /**
     * ID of the attached target group to attach to the network load balancer.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    attachedTargetGroup: AttachedTargetGroup;
}

export interface AttachNetworkLoadBalancerTargetGroupMetadata {
    /**
     * ID of the network load balancer that the target group is being attached to.
     */
    networkLoadBalancerId?: string;

    /**
     * ID of the target group.
     */
    targetGroupId?: string;
}

export interface DetachNetworkLoadBalancerTargetGroupRequest {
    /**
     * ID of the network load balancer to detach the target group from.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;

    /**
     * ID of the target group.
     */
    targetGroupId: string;
}

export interface DetachNetworkLoadBalancerTargetGroupMetadata {
    /**
     * ID of the network load balancer that the target group is being detached from.
     */
    networkLoadBalancerId?: string;

    /**
     * ID of the target group.
     */
    targetGroupId?: string;
}

export interface AddNetworkLoadBalancerListenerRequest {
    /**
     * ID of the network load balancer to add a listener to.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;

    /**
     * Listener spec.
     */
    listenerSpec: ListenerSpec;
}

export interface AddNetworkLoadBalancerListenerMetadata {
    /**
     * ID of the network load balancer that the listener is being added to.
     */
    networkLoadBalancerId?: string;
}

export interface RemoveNetworkLoadBalancerListenerRequest {
    /**
     * ID of the network load balancer to remove the listener from.
     * To get the network load balancer ID, use a [NetworkLoadBalancerService.List] request.
     */
    networkLoadBalancerId: string;

    /**
     * Name of the listener to delete.
     */
    listenerName: string;
}

export interface RemoveNetworkLoadBalancerListenerMetadata {
    /**
     * ID of the network load balancer that the listener is being removed from.
     */
    networkLoadBalancerId?: string;
}

export interface ListNetworkLoadBalancerOperationsRequest {
    /**
     * ID of the NetworkLoadBalancer resource to list operations for.
     */
    networkLoadBalancerId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than [page_size], the service returns a [ListNetworkLoadBalancerOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListNetworkLoadBalancerOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListNetworkLoadBalancerOperationsResponse {
    /**
     * List of operations for the specified network load balancer.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListNetworkLoadBalancerOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListNetworkLoadBalancerOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface GetTargetStatesRequest {
    /**
     * ID of the NetworkLoadBalancer resource with an attached target group.
     */
    networkLoadBalancerId?: string;

    /**
     * ID of the target group to get states of resources from.
     */
    targetGroupId?: string;
}

export interface GetTargetStatesResponse {
    /**
     * List of states of targets within the target group that is specified in the [GetTargetStatesRequest] message.
     */
    targetStates?: TargetState[];
}

/**
 * External address specification that is used by [ListenerSpec].
 */
export interface ExternalAddressSpec {
    /**
     * Public IP address for a listener.
     * If you provide a static public IP address for the [NetworkLoadBalancerService.Update]
     * method, it will replace the existing listener address.
     */
    address?: string;

    /**
     * IP version.
     */
    ipVersion?: IpVersion;
}

/**
 * Internal address specification that is used by [ListenerSpec].
 */
export interface InternalAddressSpec {
    /**
     * Internal IP address for a listener.
     */
    address?: string;

    /**
     * ID of the subnet.
     */
    subnetId?: string;

    /**
     * IP version.
     */
    ipVersion?: IpVersion;
}

/**
 * Listener specification that will be used by a network load balancer.
 */
export interface ListenerSpec {
    /**
     * Name of the listener. The name must be unique for each listener on a single load balancer. 3-63 characters long.
     */
    name: string;

    /**
     * Port for incoming traffic.
     */
    port?: Long;

    /**
     * Protocol for incoming traffic.
     */
    protocol: Listener.Protocol;

    /**
     * External IP address specification.
     */
    externalAddressSpec?: ExternalAddressSpec;

    /**
     * Internal IP address specification.
     */
    internalAddressSpec?: InternalAddressSpec;

    /**
     * Port of a target.
     * Acceptable values are 1 to 65535, inclusive.
     */
    targetPort?: Long;
}

/**
 * A TargetGroup resource. For more information, see [Target groups and resources](/docs/load-balancer/target-resources).
 */
export interface TargetGroup {
    /**
     * Output only. ID of the target group.
     */
    id?: string;

    /**
     * ID of the folder that the target group belongs to.
     */
    folderId?: string;

    /**
     * Output only. Creation timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the target group.
     * The name is unique within the folder. 3-63 characters long.
     */
    name?: string;

    /**
     * Description of the target group. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs. Ðœaximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the region where the target group resides.
     */
    regionId?: string;

    /**
     * A list of targets in the target group.
     */
    targets?: Target[];
}

/**
 * A Target resource. For more information, see [Target groups and resources](/docs/load-balancer/concepts/target-resources).
 */
export interface Target {
    /**
     * ID of the subnet that targets are connected to.
     * All targets in the target group must be connected to the same subnet within a single availability zone.
     */
    subnetId?: string;

    /**
     * IP address of the target.
     */
    address?: string;
}

/**
 * A set of methods for managing TargetGroup resources.
 */
export class TargetGroupService {
    constructor(session?: Session);
    /**
     * Returns the specified TargetGroup resource.
     */
    get(request: GetTargetGroupRequest): Promise<TargetGroup>;

    /**
     * Retrieves the list of TargetGroup resources in the specified folder.
     */
    list(request: ListTargetGroupsRequest): Promise<ListTargetGroupsResponse>;

    /**
     * Creates a target group in the specified folder and adds the specified targets to it.
     */
    create(request: CreateTargetGroupRequest): Promise<operation.Operation>;

    /**
     * Updates the specified target group.
     */
    update(request: UpdateTargetGroupRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified target group.
     */
    delete(request: DeleteTargetGroupRequest): Promise<operation.Operation>;

    /**
     * Adds targets to the target group.
     */
    addTargets(request: AddTargetsRequest): Promise<operation.Operation>;

    /**
     * Removes targets from the target group.
     */
    removeTargets(request: RemoveTargetsRequest): Promise<operation.Operation>;

    /**
     * Lists operations for the specified target group.
     */
    listOperations(
        request: ListTargetGroupOperationsRequest
    ): Promise<ListTargetGroupOperationsResponse>;
}

export interface GetTargetGroupRequest {
    /**
     * ID of the TargetGroup resource to return.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;
}

export interface ListTargetGroupsRequest {
    /**
     * ID of the folder to list target groups in.
     * To get the folder ID, use a [TargetGroupService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListTargetGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListTargetGroupsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can only filter by the [TargetGroup.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, or `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z][-a-z0-9]{1,61}[a-z0-9]$`.
     */
    filter?: string;
}

export interface ListTargetGroupsResponse {
    /**
     * List of TargetGroup resources.
     */
    targetGroups?: TargetGroup[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListTargetGroupsRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListTargetGroupsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateTargetGroupRequest {
    /**
     * ID of the folder to list target groups in.
     * To get the folder ID, use a [TargetGroupService.List] request.
     */
    folderId: string;

    /**
     * Name of the target group.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the target group.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the availability zone where the target group resides.
     */
    regionId: string;

    /**
     * List of targets within the target group.
     */
    targets?: Target[];
}

export interface CreateTargetGroupMetadata {
    /**
     * ID of the target group that is being created.
     */
    targetGroupId?: string;
}

export interface UpdateTargetGroupRequest {
    /**
     * ID of the TargetGroup resource to update.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;

    /**
     * Field mask that specifies which fields of the TargetGroup resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the target group.
     * The name must be unique within the folder.
     */
    name?: string;

    /**
     * Description of the target group.
     */
    description?: string;

    /**
     * Resource labels as `` key:value `` pairs.
     *
     * The existing set of `` labels `` is completely replaced with the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * A new list of targets for this target group.
     */
    targets?: Target[];
}

export interface UpdateTargetGroupMetadata {
    /**
     * ID of the target group that is being updated.
     */
    targetGroupId?: string;
}

export interface DeleteTargetGroupRequest {
    /**
     * ID of the target group to delete.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;
}

export interface DeleteTargetGroupMetadata {
    /**
     * ID of the target group that is being deleted.
     */
    targetGroupId?: string;
}

export interface AddTargetsRequest {
    /**
     * ID of the TargetGroup resource to add targets to.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;

    /**
     * List of targets to add to the target group.
     */
    targets?: Target[];
}

export interface AddTargetsMetadata {
    /**
     * ID of the target group that targets are being added to.
     */
    targetGroupId?: string;
}

export interface RemoveTargetsRequest {
    /**
     * ID of the target group to remove targets from.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;

    /**
     * List of targets to remove from the target group.
     */
    targets?: Target[];
}

export interface RemoveTargetsMetadata {
    /**
     * ID of the target group that targets are being removed from.
     */
    targetGroupId?: string;
}

export interface ListTargetGroupOperationsRequest {
    /**
     * ID of the TargetGroup resource to update.
     * To get the target group ID, use a [TargetGroupService.List] request.
     */
    targetGroupId: string;

    /**
     * The maximum number of results per page that should be returned. If the number of available
     * results is larger than [page_size], the service returns a [ListTargetGroupOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     * Default value: 100.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListTargetGroupOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListTargetGroupOperationsResponse {
    /**
     * List of operations for the specified target group.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListTargetGroupOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListTargetGroupOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}
