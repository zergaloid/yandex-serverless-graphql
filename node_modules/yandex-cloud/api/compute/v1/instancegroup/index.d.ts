// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../../index.js';

import * as protobuf from '../../../../contrib/google/protobuf';
import * as operation from '../../../../api/operation';

export interface InstanceGroup {
    /**
     * ID of the instance group.
     */
    id?: string;

    /**
     * ID of the folder that the instance group belongs to.
     */
    folderId?: string;

    /**
     * Creation timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the instance group.
     * The name is unique within the folder.
     */
    name?: string;

    /**
     * Description of the instance group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Instance template for creating the instance group.
     * For more information, see [Instance Templates](/docs/compute/concepts/ig-instance-templates).
     */
    instanceTemplate?: InstanceTemplate;

    /**
     * [Scaling policy](/docs/compute/concepts/instance-groups/scale) of the instance group.
     */
    scalePolicy?: ScalePolicy;

    /**
     * Deployment policy of the instance group.
     */
    deployPolicy?: DeployPolicy;

    /**
     * Allocation policy of the instance group by zones and regions.
     */
    allocationPolicy?: AllocationPolicy;

    /**
     * Information that indicates which entities can be related to this load balancer.
     */
    loadBalancerState?: LoadBalancerState;

    /**
     * States of instances for this instance group.
     */
    managedInstancesState?: ManagedInstancesState;

    /**
     * Load balancing specification.
     */
    loadBalancerSpec?: LoadBalancerSpec;

    /**
     * Health checking specification. For more information, see [Health check](/docs/load-balancer/concepts/health-check).
     */
    healthChecksSpec?: HealthChecksSpec;

    /**
     * ID of the service account. The service account will be used for all API calls
     * made by the Instance Groups component on behalf of the user (for example, creating instances, adding them to load balancer target group, etc.). For more information, see [Service accounts](/docs/iam/concepts/users/service-accounts).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    /**
     * Status of the instance group.
     */
    status?: InstanceGroup.Status;

    variables?: Variable[];
}

export namespace InstanceGroup {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Instance group is being started and will become active soon.
         */
        STARTING = 1,

        /**
         * Instance group is active.
         * In this state the group manages its instances and monitors their health,
         * creating, deleting, stopping, updating and starting instances as needed.
         * To stop the instance group, call [yandex.cloud.compute.v1.instancegroup.InstanceGroupService.Stop].
         */
        ACTIVE = 2,

        /**
         * Instance group is being stopped.
         * Group's instances stop receiving traffic from the load balancer (if any) and are then stopped.
         */
        STOPPING = 3,

        /**
         * Instance group is stopped.
         * In this state the group cannot be updated and does not react to any changes made to its instances.
         * To start the instance group, call [yandex.cloud.compute.v1.instancegroup.InstanceGroupService.Start].
         */
        STOPPED = 4,

        /**
         * Instance group is being deleted.
         */
        DELETING = 5,
    }
}

export interface Variable {
    key?: string;

    value?: string;
}

export interface LoadBalancerState {
    /**
     * ID of the target group used for load balancing.
     */
    targetGroupId?: string;

    /**
     * Status message of the target group.
     */
    statusMessage?: string;
}

export interface ManagedInstancesState {
    /**
     * Target number of instances for this instance group.
     */
    targetSize?: Long;

    /**
     * The number of running instances that match the current instance template. For more information, see [ManagedInstance.Status.RUNNING_ACTUAL].
     */
    runningActualCount?: Long;

    /**
     * The number of running instances that does not match the current instance template. For more information, see [ManagedInstance.Status.RUNNING_OUTDATED].
     */
    runningOutdatedCount?: Long;

    /**
     * The number of instances in flight (for example, updating, starting, deleting). For more information, see [ManagedInstance.Status].
     */
    processingCount?: Long;
}

export namespace ManagedInstancesState {
    export interface Statuses {
        /**
         * Instance is being created.
         */
        creating?: Long;

        /**
         * Instance is being started.
         */
        starting?: Long;

        /**
         * Instance is being opened to receive traffic.
         */
        opening?: Long;

        /**
         * Instance is being warmed.
         */
        warming?: Long;

        /**
         * Instance is running normally.
         */
        running?: Long;

        /**
         * Instance is being closed to traffic.
         */
        closing?: Long;

        /**
         * Instance is being stopped.
         */
        stopping?: Long;

        /**
         * Instance is being updated.
         */
        updating?: Long;

        /**
         * Instance is being deleted.
         */
        deleting?: Long;

        /**
         * Instance failed and needs to be recreated.
         */
        failed?: Long;
    }
}

export interface ScalePolicy {
    /**
     * [Manual scaling policy](/docs/compute/concepts/instance-groups/scale#fixed-policy) of the instance group.
     */
    fixedScale?: ScalePolicy.FixedScale;

    /**
     * [Automatic scaling policy](/docs/compute/concepts/instance-groups/scale#auto-scale) of the instance group.
     */
    autoScale?: ScalePolicy.AutoScale;
}

export namespace ScalePolicy {
    export interface AutoScale {
        /**
         * Lower limit for instance count in each zone.
         */
        minZoneSize?: Long;

        /**
         * Upper limit for total instance count (across all zones).
         * 0 means maximum limit = 100.
         */
        maxSize?: Long;

        /**
         * Time in seconds allotted for averaging metrics.
         */
        measurementDuration: protobuf.Duration;

        /**
         * The warmup time of the instance in seconds. During this time,
         * traffic is sent to the instance, but instance metrics are not collected.
         */
        warmupDuration?: protobuf.Duration;

        /**
         * Minimum amount of time in seconds allotted for monitoring before
         * Instance Groups can reduce the number of instances in the group.
         * During this time, the group size doesn't decrease, even if the new metric values
         * indicate that it should.
         */
        stabilizationDuration?: protobuf.Duration;

        /**
         * Target group size.
         */
        initialSize?: Long;

        /**
         * Defines an autoscaling rule based on the average CPU utilization of the instance group.
         */
        cpuUtilizationRule?: CpuUtilizationRule;

        /**
         * Defines an autoscaling rule based on a [custom metric](/docs/monitoring/operations/metric/add) from Yandex Monitoring.
         */
        customRules?: CustomRule[];
    }

    export interface CpuUtilizationRule {
        /**
         * Target CPU utilization level. Instance Groups maintains this level for each availability zone.
         */
        utilizationTarget?: number;
    }

    export interface CustomRule {
        /**
         * Custom metric rule type. This field affects which label from
         * the custom metric should be used: `zone_id` or `instance_id`.
         */
        ruleType: CustomRule.RuleType;

        /**
         * Type of custom metric. This field affects how Instance Groups calculates the average metric value.
         */
        metricType: CustomRule.MetricType;

        /**
         * Name of custom metric in Yandex Monitoring that should be used for scaling.
         */
        metricName: string;

        /**
         * Labels of custom metric in Yandex Monitoring that should be used for scaling.
         */
        labels?: { [s: string]: string };

        /**
         * Target value for the custom metric. Instance Groups maintains this level for each availability zone.
         */
        target?: number;
    }

    export namespace CustomRule {
        export enum RuleType {
            RULE_TYPE_UNSPECIFIED = 0,

            /**
             * This type means that the metric applies to one instance.
             * First, Instance Groups calculates the average metric value for each instance,
             * then averages the values for instances in one availability zone.
             * This type of metric must have the `instance_id` label.
             */
            UTILIZATION = 1,

            /**
             * This type means that the metric applies to instances in one availability zone.
             * This type of metric must have the `zone_id` label.
             */
            WORKLOAD = 2,
        }

        export enum MetricType {
            METRIC_TYPE_UNSPECIFIED = 0,

            /**
             * This type is used for metrics that show the metric value at a certain point in time,
             * such as requests per second to the server on an instance.
             *
             * Instance Groups calculates the average metric value for the period
             * specified in the [AutoScale.measurement_duration] field.
             */
            GAUGE = 1,

            /**
             * This type is used for metrics that monotonically increase over time,
             * such as the total number of requests to the server on an instance.
             *
             * Instance Groups calculates the average value increase for the period
             * specified in the [AutoScale.measurement_duration] field.
             */
            COUNTER = 2,
        }
    }

    export interface FixedScale {
        /**
         * Number of instances in the instance group.
         */
        size?: Long;
    }
}

export interface DeployPolicy {
    /**
     * The maximum number of running instances that can be taken offline (i.e., stopped or deleted) at the same time
     * during the update process.
     * If [max_expansion] is not specified or set to zero, [max_unavailable] must be set to a non-zero value.
     */
    maxUnavailable?: Long;

    /**
     * The maximum number of instances that can be deleted at the same time.
     */
    maxDeleting?: Long;

    /**
     * The maximum number of instances that can be created at the same time.
     */
    maxCreating?: Long;

    /**
     * The maximum number of instances that can be temporarily allocated above the group's target size
     * during the update process.
     * If [max_unavailable] is not specified or set to zero, [max_expansion] must be set to a non-zero value.
     */
    maxExpansion?: Long;

    /**
     * Instance startup duration.
     * Instance will be considered up and running (and start receiving traffic) only after startup_duration
     * has elapsed and all health checks are passed.
     * See [yandex.cloud.compute.v1.instancegroup.ManagedInstance.Status] for more information.
     */
    startupDuration?: protobuf.Duration;
}

export interface AllocationPolicy {
    /**
     * List of availability zones.
     */
    zones?: AllocationPolicy.Zone[];
}

export namespace AllocationPolicy {
    export interface Zone {
        /**
         * ID of the availability zone where the instance resides.
         */
        zoneId: string;
    }
}

export interface InstanceTemplate {
    /**
     * Description of the instance template.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the hardware platform configuration for the instance.
     * Platforms allows you to create various types of instances: with a large amount of memory,
     * with a large number of cores, with a burstable performance.
     * For more information, see [Platforms](/docs/compute/concepts/vm-platforms).
     */
    platformId: string;

    /**
     * Computing resources of the instance such as the amount of memory and number of cores.
     */
    resourcesSpec: ResourcesSpec;

    /**
     * The metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys.
     *
     * Metadata values may contain one of the supported placeholders:
     * {instance_group.id}
     * {instance.short_id}
     * {instance.index}
     * {instance.index_in_zone}
     * {instance.zone_id}
     * InstanceGroup and Instance labels may be copied to metadata following way:
     * {instance_group.labels.some_label_key}
     * {instance.labels.another_label_key}
     * These placeholders will be substituted for each created instance anywhere in the value text.
     * In the rare case the value requires to contain this placeholder explicitly,
     * it must be escaped with double brackets, in example {instance.index}.
     *
     * For example, you may use the metadata in order to provide your public SSH key to the instance.
     * For more information, see [Metadata](/docs/compute/concepts/vm-metadata).
     */
    metadata?: { [s: string]: string };

    /**
     * Boot disk specification that will be attached to the instance.
     */
    bootDiskSpec: AttachedDiskSpec;

    /**
     * Array of secondary disks that will be attached to the instance.
     */
    secondaryDiskSpecs?: AttachedDiskSpec[];

    /**
     * Array of network interfaces that will be attached to the instance.
     */
    networkInterfaceSpecs?: NetworkInterfaceSpec[];

    /**
     * Scheduling policy for the instance.
     */
    schedulingPolicy?: SchedulingPolicy;

    /**
     * Service account ID for the instance.
     */
    serviceAccountId?: string;

    /**
     * Network settings for the instance.
     */
    networkSettings?: NetworkSettings;

    /**
     * Name of the instance.
     * In order to be unique it must contain at least on of instance unique placeholders:
     * {instance.short_id}
     * {instance.index}
     * combination of {instance.zone_id} and {instance.index_in_zone}
     * Example: my-instance-{instance.index}
     * If not set, default is used: {instance_group.id}-{instance.short_id}
     * It may also contain another placeholders, see metadata doc for full list.
     */
    name?: string;

    /**
     * Host name for the instance.
     * This field is used to generate the [yandex.cloud.compute.v1.Instance.fqdn] value.
     * The host name must be unique within the network and region.
     * If not specified, the host name will be equal to [yandex.cloud.compute.v1.Instance.id] of the instance
     * and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
     *
     * In order to be unique it must contain at least on of instance unique placeholders:
     * {instance.short_id}
     * {instance.index}
     * combination of {instance.zone_id} and {instance.index_in_zone}
     * Example: my-instance-{instance.index}
     * If not set, `name` value will be used
     * It may also contain another placeholders, see metadata doc for full list.
     */
    hostname?: string;
}

export interface ResourcesSpec {
    /**
     * The amount of memory available to the instance, specified in bytes.
     */
    memory?: Long;

    /**
     * The number of cores available to the instance.
     */
    cores?: Long;

    /**
     * Baseline level of CPU performance with the ability to burst performance above that baseline level.
     * This field sets baseline performance for each core.
     */
    coreFraction?: Long;

    /**
     * The number of GPUs available to the instance.
     */
    gpus?: Long;
}

export interface AttachedDiskSpec {
    /**
     * Access mode to the Disk resource.
     */
    mode: AttachedDiskSpec.Mode;

    /**
     * Serial number that is reflected in the /dev/disk/by-id/ tree
     * of a Linux operating system running within the instance.
     *
     * This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
     */
    deviceName?: string;

    /**
     * Disk specification that is attached to the instance. For more information, see [Disks](/docs/compute/concepts/disk).
     */
    diskSpec: AttachedDiskSpec.DiskSpec;
}

export namespace AttachedDiskSpec {
    export enum Mode {
        MODE_UNSPECIFIED = 0,

        /**
         * Read-only access.
         */
        READ_ONLY = 1,

        /**
         * Read/Write access.
         */
        READ_WRITE = 2,
    }

    export interface DiskSpec {
        /**
         * Description of the disk.
         */
        description?: string;

        /**
         * ID of the disk type.
         */
        typeId: string;

        /**
         * Size of the disk, specified in bytes.
         */
        size?: Long;

        /**
         * ID of the image that will be used for disk creation.
         */
        imageId?: string;

        /**
         * ID of the snapshot that will be used for disk creation.
         */
        snapshotId?: string;
    }
}

export interface NetworkInterfaceSpec {
    /**
     * ID of the network.
     */
    networkId?: string;

    /**
     * IDs of the subnets.
     */
    subnetIds?: string[];

    /**
     * Primary IPv4 address that is assigned to the instance for this network interface.
     */
    primaryV4AddressSpec?: PrimaryAddressSpec;

    /**
     * Primary IPv6 address that is assigned to the instance for this network interface. IPv6 not available yet.
     */
    primaryV6AddressSpec?: PrimaryAddressSpec;
}

export interface PrimaryAddressSpec {
    /**
     * An external IP address configuration.
     * If not specified, then this managed instance will have no external internet access.
     */
    oneToOneNatSpec?: OneToOneNatSpec;
}

export interface OneToOneNatSpec {
    /**
     * IP version for the public IP address.
     */
    ipVersion?: IpVersion;
}

export enum IpVersion {
    IP_VERSION_UNSPECIFIED = 0,

    /**
     * IPv4 address, for example 192.168.0.0.
     */
    IPV4 = 1,

    /**
     * IPv6 address, not available yet.
     */
    IPV6 = 2,
}

export interface SchedulingPolicy {
    /**
     * Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time
     * if their resources are needed by Compute.
     * For more information, see [Preemptible Virtual Machines](/docs/compute/concepts/preemptible-vm).
     */
    preemptible?: boolean;
}

export interface NetworkSettings {
    /**
     * Type of instance network.
     */
    type?: NetworkSettings.Type;
}

export namespace NetworkSettings {
    export enum Type {
        TYPE_UNSPECIFIED = 0,

        STANDARD = 1,

        SOFTWARE_ACCELERATED = 2,

        HARDWARE_ACCELERATED = 3,
    }
}

export interface LoadBalancerSpec {
    /**
     * Specification of the target group that the instance group will be added to. For more information, see [Target groups and resources](/docs/load-balancer/target-resources).
     */
    targetGroupSpec?: TargetGroupSpec;
}

export interface TargetGroupSpec {
    /**
     * Name of the target group.
     */
    name?: string;

    /**
     * Description of the target group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };
}

export interface HealthChecksSpec {
    /**
     * Health checking specification. For more information, see [Health check](/docs/load-balancer/concepts/health-check).
     */
    healthCheckSpecs?: HealthCheckSpec[];
}

export interface HealthCheckSpec {
    /**
     * The interval between health checks. The default is 2 seconds.
     */
    interval?: protobuf.Duration;

    /**
     * Timeout for the managed instance to return a response for the health check. The default is 1 second.
     */
    timeout?: protobuf.Duration;

    /**
     * The number of failed health checks for the managed instance to be considered unhealthy. The default (0) is 2.
     */
    unhealthyThreshold?: Long;

    /**
     * The number of successful health checks required in order for the managed instance to be considered healthy. The default (0) is 2.
     */
    healthyThreshold?: Long;

    /**
     * Configuration options for a TCP health check.
     */
    tcpOptions?: HealthCheckSpec.TcpOptions;

    /**
     * Configuration options for an HTTP health check.
     */
    httpOptions?: HealthCheckSpec.HttpOptions;
}

export namespace HealthCheckSpec {
    export interface TcpOptions {
        /**
         * Port to use for TCP health checks.
         */
        port?: Long;
    }

    export interface HttpOptions {
        /**
         * Port to use for HTTP health checks.
         */
        port?: Long;

        /**
         * URL path to set for health checking requests.
         */
        path?: string;
    }
}

/**
 * A ManagedInstance resource. For more information, see [Instance Groups Concepts](/docs/compute/concepts/instance-groups/).
 */
export interface ManagedInstance {
    /**
     * ID of the managed instance.
     */
    id?: string;

    /**
     * Status of the managed instance.
     */
    status?: ManagedInstance.Status;

    /**
     * ID of the instance.
     */
    instanceId?: string;

    /**
     * Fully Qualified Domain Name.
     */
    fqdn?: string;

    /**
     * The name of the managed instance.
     */
    name?: string;

    /**
     * Status message for the managed instance.
     */
    statusMessage?: string;

    /**
     * ID of the availability zone where the instance resides.
     */
    zoneId?: string;

    /**
     * Array of network interfaces that are attached to the managed instance.
     */
    networkInterfaces?: NetworkInterface[];

    /**
     * The timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format when the status of the managed instance was last changed.
     */
    statusChangedAt?: protobuf.Timestamp;
}

export namespace ManagedInstance {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Instance is being created.
         */
        CREATING_INSTANCE = 11,

        /**
         * Instance is being updated.
         */
        UPDATING_INSTANCE = 12,

        /**
         * Instance is being deleted.
         */
        DELETING_INSTANCE = 13,

        /**
         * Instance is being started.
         */
        STARTING_INSTANCE = 14,

        /**
         * Instance is being stopped.
         */
        STOPPING_INSTANCE = 15,

        /**
         * Instance has been created successfully, but startup duration has not elapsed yet.
         */
        AWAITING_STARTUP_DURATION = 16,

        /**
         * Instance has been created successfully and startup duration has elapsed, but health checks have not passed yet and the managed instance is not ready to receive traffic.
         */
        CHECKING_HEALTH = 17,

        /**
         * Instance Groups is initiating health checks and routing traffic to the instances.
         */
        OPENING_TRAFFIC = 18,

        /**
         * Instance is now receiving traffic, but warmup duration has not elapsed yet.
         */
        AWAITING_WARMUP_DURATION = 19,

        /**
         * Instance Groups has initiated the process of stopping routing traffic to the instances.
         */
        CLOSING_TRAFFIC = 20,

        /**
         * Instance is running normally and its attributes match the current InstanceTemplate.
         */
        RUNNING_ACTUAL = 21,

        /**
         * Instance is running normally, but its attributes do not match the current InstanceTemplate.
         * It will be updated, recreated or deleted shortly.
         */
        RUNNING_OUTDATED = 22,

        /**
         * Instance was stopped.
         */
        STOPPED = 23,

        /**
         * Instance was deleted.
         */
        DELETED = 24,
    }
}

export interface NetworkInterface {
    /**
     * The index of the network interface, generated by the server, 0,1,2... etc.
     * Currently only one network interface is supported per instance.
     */
    index?: string;

    /**
     * MAC address that is assigned to the network interface.
     */
    macAddress?: string;

    /**
     * ID of the subnet.
     */
    subnetId?: string;

    /**
     * Primary IPv4 address that is assigned to the instance for this network interface.
     */
    primaryV4Address?: PrimaryAddress;

    /**
     * Primary IPv6 address that is assigned to the instance for this network interface. IPv6 is not available yet.
     */
    primaryV6Address?: PrimaryAddress;
}

export interface PrimaryAddress {
    /**
     * An IPv4 internal network address that is assigned to the managed instance for this network interface.
     * If not specified by the user, an unused internal IP is assigned by the system.
     */
    address?: string;

    /**
     * One-to-one NAT configuration. If missing, NAT has not been set up.
     */
    oneToOneNat?: OneToOneNat;
}

export interface OneToOneNat {
    /**
     * An IPv4 external network address that is assigned to the managed instance for this network interface.
     */
    address?: string;

    /**
     * External IP address version.
     */
    ipVersion?: IpVersion;
}

export interface LogRecord {
    /**
     * Log timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     */
    timestamp?: protobuf.Timestamp;

    /**
     * The log message.
     */
    message?: string;
}

/**
 * A set of methods for managing InstanceGroup resources.
 */
export class InstanceGroupService {
    constructor(session?: Session);
    /**
     * Returns the specified InstanceGroup resource.
     *
     * To get the list of available InstanceGroup resources, make a [List] request.
     */
    get(request: GetInstanceGroupRequest): Promise<InstanceGroup>;

    /**
     * Retrieves the list of InstanceGroup resources in the specified folder.
     */
    list(
        request: ListInstanceGroupsRequest
    ): Promise<ListInstanceGroupsResponse>;

    /**
     * Creates an instance group in the specified folder.
     * This method starts an operation that can be cancelled by another operation.
     */
    create(request: CreateInstanceGroupRequest): Promise<operation.Operation>;

    /**
     * Creates an instance group in the specified folder from a YAML file.
     * This method starts an operation that can be cancelled by another operation.
     */
    createFromYaml(
        request: CreateInstanceGroupFromYamlRequest
    ): Promise<operation.Operation>;

    /**
     * Updates the specified instance group.
     * This method starts an operation that can be cancelled by another operation.
     */
    update(request: UpdateInstanceGroupRequest): Promise<operation.Operation>;

    /**
     * Updates the specified instance group from a YAML file.
     * This method starts an operation that can be cancelled by another operation.
     */
    updateFromYaml(
        request: UpdateInstanceGroupFromYamlRequest
    ): Promise<operation.Operation>;

    /**
     * Stops the specified instance group.
     */
    stop(request: StopInstanceGroupRequest): Promise<operation.Operation>;

    /**
     * Starts the specified instance group.
     */
    start(request: StartInstanceGroupRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified instance group.
     */
    delete(request: DeleteInstanceGroupRequest): Promise<operation.Operation>;

    /**
     * Lists instances for the specified instance group.
     */
    listInstances(
        request: ListInstanceGroupInstancesRequest
    ): Promise<ListInstanceGroupInstancesResponse>;

    /**
     * Lists operations for the specified instance group.
     */
    listOperations(
        request: ListInstanceGroupOperationsRequest
    ): Promise<ListInstanceGroupOperationsResponse>;

    /**
     * Lists logs for the specified instance group.
     */
    listLogRecords(
        request: ListInstanceGroupLogRecordsRequest
    ): Promise<ListInstanceGroupLogRecordsResponse>;
}

export enum InstanceGroupView {
    /**
     * Doesn't include the metadata of the instance template in the server response.
     */
    BASIC = 0,

    /**
     * Returns the metadata of the instance template in the server response.
     */
    FULL = 1,
}

export interface GetInstanceGroupRequest {
    /**
     * ID of the InstanceGroup resource to return.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * Defines which information about the Instance template should be returned in the server response.
     */
    view?: InstanceGroupView;
}

export interface CreateInstanceGroupRequest {
    /**
     * ID of the folder to create an instance group in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the instance group.
     */
    name?: string;

    /**
     * Description of the instance group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Instance template that the instance group belongs to.
     */
    instanceTemplate: InstanceTemplate;

    /**
     * [Scaling policy](/docs/compute/concepts/instance-groups/scale) of the instance group.
     */
    scalePolicy: ScalePolicy;

    /**
     * Deployment policy of the instance group.
     */
    deployPolicy: DeployPolicy;

    /**
     * Allocation policy of the instance group by zones and regions.
     */
    allocationPolicy: AllocationPolicy;

    /**
     * Load balancing specification.
     */
    loadBalancerSpec?: LoadBalancerSpec;

    /**
     * Health checking specification. For more information, see [Health check](/docs/load-balancer/concepts/health-check).
     */
    healthChecksSpec?: HealthChecksSpec;

    /**
     * ID of the service account. The service account will be used for all API calls
     * made by the Instance Groups component on behalf of the user (for example, creating instances, adding them to load balancer target group, etc.). For more information, see [Service accounts](/docs/iam/concepts/users/service-accounts).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    variables?: Variable[];
}

export interface CreateInstanceGroupFromYamlRequest {
    /**
     * ID of the folder to create an instance group in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * [InstanceGroupService.Create] request in YAML format.
     */
    instanceGroupYaml: string;
}

export interface CreateInstanceGroupMetadata {
    /**
     * ID of the instance group that is being created.
     */
    instanceGroupId?: string;
}

export interface UpdateInstanceGroupRequest {
    /**
     * ID of the instance group to update.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * Field mask that specifies which fields of the InstanceGroup resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the instance group.
     */
    name?: string;

    /**
     * Description of the instance group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * The existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * Instance template that the instance group belongs to.
     */
    instanceTemplate: InstanceTemplate;

    /**
     * [Scaling policy](/docs/compute/concepts/instance-groups/scale) of the instance group.
     */
    scalePolicy: ScalePolicy;

    /**
     * Deployment policy of the instance group.
     */
    deployPolicy: DeployPolicy;

    /**
     * Allocation policy of the instance group by zones and regions.
     */
    allocationPolicy: AllocationPolicy;

    /**
     * Health checking specification. For more information, see [Health check](/docs/load-balancer/concepts/health-check).
     */
    healthChecksSpec?: HealthChecksSpec;

    /**
     * ID of the service account. The service account will be used for all API calls
     * made by the Instance Groups component on behalf of the user (for example, creating instances, adding them to load balancer target group, etc.). For more information, see [Service accounts](/docs/iam/concepts/users/service-accounts).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    /**
     * Load Balancer specification for load balancing support.
     */
    loadBalancerSpec?: LoadBalancerSpec;

    variables?: Variable[];
}

export interface UpdateInstanceGroupFromYamlRequest {
    /**
     * ID of the instance group to update.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * [InstanceGroupService.Update] request in YAML format.
     */
    instanceGroupYaml: string;
}

export interface UpdateInstanceGroupMetadata {
    /**
     * ID of the InstanceGroup resource that is being updated.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId?: string;
}

export interface StartInstanceGroupRequest {
    /**
     * ID of the instance group to start.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;
}

export interface StartInstanceGroupMetadata {
    /**
     * ID of the InstanceGroup resource that is being started.
     */
    instanceGroupId?: string;
}

export interface StopInstanceGroupRequest {
    /**
     * ID of the instance group to stop.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;
}

export interface StopInstanceGroupMetadata {
    /**
     * ID of the InstanceGroup resource that is being stopped.
     */
    instanceGroupId?: string;
}

export interface DeleteInstanceGroupRequest {
    /**
     * ID of the instance group to delete.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;
}

export interface DeleteInstanceGroupMetadata {
    /**
     * ID of the instance group that is being deleted.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId?: string;
}

export interface DeleteInstancesMetadata {
    /**
     * ID of the instance group that the instances are being deleted from.
     */
    instanceGroupId?: string;
}

export interface ListInstanceGroupsRequest {
    /**
     * ID of the folder to list instance groups in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListInstanceGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListInstanceGroupsResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on the [InstanceGroup.name] field.
     */
    filter?: string;

    /**
     * Defines which information about the Instance template should be returned in the server response.
     */
    view?: InstanceGroupView;
}

export interface ListInstanceGroupsResponse {
    /**
     * Lists instance groups for the specified folder.
     */
    instanceGroups?: InstanceGroup[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListInstanceGroupsRequest.page_size], use
     * [next_page_token] as the value
     * for the [ListInstanceGroupsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListInstanceGroupInstancesRequest {
    /**
     * ID of the InstanceGroup resource to list instances for.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListInstanceGroupInstancesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListInstanceGroupInstancesResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on the [InstanceGroup.name] field.
     */
    filter?: string;
}

export interface ListInstanceGroupInstancesResponse {
    /**
     * Lists instances for the specified instance group.
     */
    instances?: ManagedInstance[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is more than [ListInstanceGroupInstancesRequest.page_size], use
     * [next_page_token] as the value
     * for the [ListInstanceGroupInstancesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListInstanceGroupOperationsRequest {
    /**
     * ID of the InstanceGroup resource to list operations for.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is more than [page_size], the service returns a [ListInstanceGroupOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListInstanceGroupOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on the [InstanceGroup.name] field.
     */
    filter?: string;
}

export interface ListInstanceGroupOperationsResponse {
    /**
     * Lists operations for the specified instance group.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is more than [ListInstanceGroupOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListInstanceGroupOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListInstanceGroupLogRecordsRequest {
    /**
     * ID of the InstanceGroup resource to list logs for.
     * To get the instance group ID, use a [InstanceGroupService.List] request.
     */
    instanceGroupId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListInstanceGroupLogRecordsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListInstanceGroupLogRecordsResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on the [InstanceGroup.name] field.
     */
    filter?: string;
}

export interface ListInstanceGroupLogRecordsResponse {
    /**
     * Lists logs for the specified instance group.
     */
    logRecords?: LogRecord[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListInstanceGroupLogRecordsRequest.page_size], use
     * [next_page_token] as the value
     * for the [ListInstanceGroupLogRecordsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}
