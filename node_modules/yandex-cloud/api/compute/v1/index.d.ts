// autogenerated file

import * as grpc from 'grpc';
import { util } from 'protobufjs';
import Long = util.Long;
import * as events from 'events';
import { Session } from '../../../index.js';

import * as protobuf from '../../../contrib/google/protobuf';
import * as operation from '../../../api/operation';

/**
 * A Disk resource. For more information, see [Disks](/docs/compute/concepts/disk).
 */
export interface Disk {
    /**
     * ID of the disk.
     */
    id?: string;

    /**
     * ID of the folder that the disk belongs to.
     */
    folderId?: string;

    createdAt?: protobuf.Timestamp;

    /**
     * Name of the disk. 1-63 characters long.
     */
    name?: string;

    /**
     * Description of the disk. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Maximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the disk type.
     */
    typeId?: string;

    /**
     * ID of the availability zone where the disk resides.
     */
    zoneId?: string;

    /**
     * Size of the disk, specified in bytes.
     */
    size?: Long;

    /**
     * License IDs that indicate which licenses are attached to this resource.
     * License IDs are used to calculate additional charges for the use of the virtual machine.
     *
     * The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
     *
     * If you know the license IDs, specify them when you create the image.
     * For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
     * You can specify them in the [yandex.cloud.compute.v1.ImageService.Create] request.
     */
    productIds?: string[];

    /**
     * Current status of the disk.
     */
    status?: Disk.Status;

    /**
     * ID of the image that was used for disk creation.
     */
    sourceImageId?: string;

    /**
     * ID of the snapshot that was used for disk creation.
     */
    sourceSnapshotId?: string;

    /**
     * Array of instances to which the disk is attached.
     */
    instanceIds?: string[];
}

export namespace Disk {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Disk is being created.
         */
        CREATING = 1,

        /**
         * Disk is ready to use.
         */
        READY = 2,

        /**
         * Disk encountered a problem and cannot operate.
         */
        ERROR = 3,

        /**
         * Disk is being deleted.
         */
        DELETING = 4,
    }
}

/**
 * A set of methods for managing Disk resources.
 */
export class DiskService {
    constructor(session?: Session);
    /**
     * Returns the specified Disk resource.
     *
     * To get the list of available Disk resources, make a [List] request.
     */
    get(request: GetDiskRequest): Promise<Disk>;

    /**
     * Retrieves the list of Disk resources in the specified folder.
     */
    list(request: ListDisksRequest): Promise<ListDisksResponse>;

    /**
     * Creates a disk in the specified folder.
     *
     * You can create an empty disk or restore it from a snapshot or an image.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create(request: CreateDiskRequest): Promise<operation.Operation>;

    /**
     * Updates the specified disk.
     */
    update(request: UpdateDiskRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified disk.
     *
     * Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete
     * any snapshots or images previously made from the disk. You must delete snapshots and images separately.
     *
     * It is not possible to delete a disk that is attached to an instance.
     */
    delete(request: DeleteDiskRequest): Promise<operation.Operation>;

    /**
     * Lists operations for the specified disk.
     */
    listOperations(
        request: ListDiskOperationsRequest
    ): Promise<ListDiskOperationsResponse>;
}

export interface GetDiskRequest {
    /**
     * ID of the Disk resource to return.
     * To get the disk ID use a [DiskService.List] request.
     */
    diskId: string;
}

export interface ListDisksRequest {
    /**
     * ID of the folder to list disks in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListDisksResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListDisksResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on the [Disk.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
     */
    filter?: string;
}

export interface ListDisksResponse {
    /**
     * List of Disk resources.
     */
    disks?: Disk[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListDisksRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListDisksRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateDiskRequest {
    /**
     * ID of the folder to create a disk in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the disk.
     */
    name?: string;

    /**
     * Description of the disk.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the disk type.
     * To get a list of available disk types use the [yandex.cloud.compute.v1.DiskTypeService.List] request.
     */
    typeId?: string;

    /**
     * ID of the availability zone where the disk resides.
     * To get a list of available zones use the [yandex.cloud.compute.v1.ZoneService.List] request.
     */
    zoneId: string;

    /**
     * Size of the disk, specified in bytes.
     * If the disk was created from a image, this value should be more than the
     * [yandex.cloud.compute.v1.Image.min_disk_size] value.
     */
    size: Long;

    /**
     * ID of the image to create the disk from.
     */
    imageId?: string;

    /**
     * ID of the snapshot to restore the disk from.
     */
    snapshotId?: string;
}

export interface CreateDiskMetadata {
    /**
     * ID of the disk that is being created.
     */
    diskId?: string;
}

export interface UpdateDiskRequest {
    /**
     * ID of the Disk resource to update.
     * To get the disk ID use a [DiskService.List] request.
     */
    diskId: string;

    /**
     * Field mask that specifies which fields of the Disk resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the disk.
     */
    name?: string;

    /**
     * Description of the disk.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * Size of the disk, specified in bytes.
     */
    size?: Long;
}

export interface UpdateDiskMetadata {
    /**
     * ID of the Disk resource that is being updated.
     */
    diskId?: string;
}

export interface DeleteDiskRequest {
    /**
     * ID of the disk to delete.
     * To get the disk ID use a [DiskService.List] request.
     */
    diskId: string;
}

export interface DeleteDiskMetadata {
    /**
     * ID of the disk that is being deleted.
     */
    diskId?: string;
}

export interface ListDiskOperationsRequest {
    /**
     * ID of the Disk resource to list operations for.
     */
    diskId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListDiskOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListDiskOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListDiskOperationsResponse {
    /**
     * List of operations for the specified disk.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListDiskOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListDiskOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface DiskType {
    /**
     * ID of the disk type.
     */
    id?: string;

    /**
     * Description of the disk type. 0-256 characters long.
     */
    description?: string;

    /**
     * Array of availability zones where the disk type is available.
     */
    zoneIds?: string[];
}

/**
 * A set of methods to retrieve information about disk types.
 */
export class DiskTypeService {
    constructor(session?: Session);
    /**
     * Returns the information about specified disk type.
     *
     * To get the list of available disk types, make a [List] request.
     */
    get(request: GetDiskTypeRequest): Promise<DiskType>;

    /**
     * Retrieves the list of disk types for the specified folder.
     */
    list(request: ListDiskTypesRequest): Promise<ListDiskTypesResponse>;
}

export interface GetDiskTypeRequest {
    /**
     * ID of the disk type to return information about.
     * To get the disk type ID use a [DiskTypeService.List] request.
     */
    diskTypeId: string;
}

export interface ListDiskTypesRequest {
    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListDiskTypesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListDiskTypesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListDiskTypesResponse {
    /**
     * List of disk types.
     */
    diskTypes?: DiskType[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListDiskTypesRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListDiskTypesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

/**
 * An Image resource.
 */
export interface Image {
    /**
     * ID of the image.
     */
    id?: string;

    /**
     * ID of the folder that the image belongs to.
     */
    folderId?: string;

    createdAt?: protobuf.Timestamp;

    /**
     * Name of the image. 1-63 characters long.
     */
    name?: string;

    /**
     * Description of the image. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Maximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * The name of the image family to which this image belongs.
     *
     * You can get the most recent image from a family by using
     * the [yandex.cloud.compute.v1.ImageService.GetLatestByFamily] request
     * and create the disk from this image.
     */
    family?: string;

    /**
     * The size of the image, specified in bytes.
     */
    storageSize?: Long;

    /**
     * Minimum size of the disk which will be created from this image.
     */
    minDiskSize?: Long;

    /**
     * License IDs that indicate which licenses are attached to this resource.
     * License IDs are used to calculate additional charges for the use of the virtual machine.
     *
     * The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
     *
     * If you know the license IDs, specify them when you create the image.
     * For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
     * You can specify them in the [yandex.cloud.compute.v1.ImageService.Create] request.
     */
    productIds?: string[];

    /**
     * Current status of the image.
     */
    status?: Image.Status;

    /**
     * Operating system that is contained in the image.
     */
    os?: Os;
}

export namespace Image {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Image is being created.
         */
        CREATING = 1,

        /**
         * Image is ready to use.
         */
        READY = 2,

        /**
         * Image encountered a problem and cannot operate.
         */
        ERROR = 3,

        /**
         * Image is being deleted.
         */
        DELETING = 4,
    }
}

export interface Os {
    /**
     * Operating system type. The default is `LINUX`.
     *
     * This field is used to correctly emulate a vCPU and calculate the cost of using an instance.
     */
    type?: Os.Type;
}

export namespace Os {
    export enum Type {
        TYPE_UNSPECIFIED = 0,

        /**
         * Linux operating system.
         */
        LINUX = 1,

        /**
         * Windows operating system.
         */
        WINDOWS = 2,
    }
}

/**
 * A set of methods for managing Image resources.
 */
export class ImageService {
    constructor(session?: Session);
    /**
     * Returns the specified Image resource.
     *
     * To get the list of available Image resources, make a [List] request.
     */
    get(request: GetImageRequest): Promise<Image>;

    /**
     * Returns the latest image that is part of an image family.
     */
    getLatestByFamily(request: GetImageLatestByFamilyRequest): Promise<Image>;

    /**
     * Retrieves the list of Image resources in the specified folder.
     */
    list(request: ListImagesRequest): Promise<ListImagesResponse>;

    /**
     * Creates an image in the specified folder.
     *
     * You can create an image from a disk, snapshot, other image or URI.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create(request: CreateImageRequest): Promise<operation.Operation>;

    /**
     * Updates the specified image.
     */
    update(request: UpdateImageRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified image.
     *
     * Deleting an image removes its data permanently and is irreversible.
     */
    delete(request: DeleteImageRequest): Promise<operation.Operation>;

    /**
     * Lists operations for the specified image.
     */
    listOperations(
        request: ListImageOperationsRequest
    ): Promise<ListImageOperationsResponse>;
}

export interface GetImageRequest {
    /**
     * ID of the Image resource to return.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;
}

export interface GetImageLatestByFamilyRequest {
    /**
     * ID of the folder to get the image from.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the image family to search for.
     */
    family?: string;
}

export interface ListImagesRequest {
    /**
     * ID of the folder to list images in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListImagesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListImagesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on the [Image.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
     */
    filter?: string;
}

export interface ListImagesResponse {
    /**
     * List of images.
     */
    images?: Image[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListSnapshotsRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListSnapshotsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateImageRequest {
    /**
     * ID of the folder to create an image in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the image.
     */
    name?: string;

    /**
     * Description of the image.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * The name of the image family to which this image belongs. For more information, see [Image family](/docs/compute/concepts/image#family).
     *
     * To get an information about the most recent image from a family, use a [ImageService.GetLatestByFamily] request.
     */
    family?: string;

    /**
     * Minimum size of the disk that will be created from this image.
     * Specified in bytes. Should be more than the volume of source data.
     */
    minDiskSize?: Long;

    /**
     * License IDs that indicate which licenses are attached to this resource.
     * License IDs are used to calculate additional charges for the use of the virtual machine.
     *
     * The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
     *
     * If you know the license IDs, specify them when you create the image.
     * For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
     * You can specify them in this request.
     */
    productIds?: string[];

    /**
     * ID of the source image to create the new image from.
     */
    imageId?: string;

    /**
     * ID of the disk to create the image from.
     */
    diskId?: string;

    /**
     * ID of the snapshot to create the image from.
     */
    snapshotId?: string;

    /**
     * URI of the source image to create the new image from.
     * Currently only supports links to images that are stored in Yandex Object Storage.
     * Currently only supports Qcow2, VMDK, and VHD formats.
     */
    uri?: string;

    /**
     * Operating system that is contained in the image.
     *
     * If not specified and you used the `image_id` or `disk_id` field to set the source, then the value can be inherited from the source resource.
     */
    os?: Os;
}

export interface CreateImageMetadata {
    /**
     * ID of the image that is being created.
     */
    imageId?: string;
}

export interface UpdateImageRequest {
    /**
     * ID of the Image resource to update.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;

    /**
     * Field mask that specifies which fields of the Image resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the image.
     */
    name?: string;

    /**
     * Description of the image.
     */
    description?: string;

    /**
     * Minimum size of the disk that can be created from this image.
     * Specified in bytes. Should be more than the volume of source data and more than the virtual disk size.
     */
    minDiskSize?: Long;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };
}

export interface UpdateImageMetadata {
    /**
     * ID of the Image resource that is being updated.
     */
    imageId?: string;
}

export interface DeleteImageRequest {
    /**
     * ID of the image to delete.
     * To get the image ID, use a [ImageService.List] request.
     */
    imageId: string;
}

export interface DeleteImageMetadata {
    /**
     * ID of the image that is being deleted.
     */
    imageId?: string;
}

export interface ListImageOperationsRequest {
    /**
     * ID of the Image resource to list operations for.
     */
    imageId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListImageOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListImageOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListImageOperationsResponse {
    /**
     * List of operations for the specified image.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListImageOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListImageOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

/**
 * An Instance resource. For more information, see [Instances](/docs/compute/concepts/vm).
 */
export interface Instance {
    /**
     * ID of the instance.
     */
    id?: string;

    /**
     * ID of the folder that the instance belongs to.
     */
    folderId?: string;

    createdAt?: protobuf.Timestamp;

    /**
     * Name of the instance. 1-63 characters long.
     */
    name?: string;

    /**
     * Description of the instance. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Maximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the availability zone where the instance resides.
     */
    zoneId?: string;

    /**
     * ID of the hardware platform configuration for the instance.
     */
    platformId?: string;

    /**
     * Computing resources of the instance such as the amount of memory and number of cores.
     */
    resources?: Resources;

    /**
     * Status of the instance.
     */
    status?: Instance.Status;

    /**
     * The metadata `key:value` pairs assigned to this instance. This includes custom metadata and predefined keys.
     *
     * For example, you may use the metadata in order to provide your public SSH key to the instance.
     * For more information, see [Metadata](/docs/compute/concepts/vm-metadata).
     */
    metadata?: { [s: string]: string };

    /**
     * Boot disk that is attached to the instance.
     */
    bootDisk?: AttachedDisk;

    /**
     * Array of secondary disks that are attached to the instance.
     */
    secondaryDisks?: AttachedDisk[];

    /**
     * Array of network interfaces that are attached to the instance.
     */
    networkInterfaces?: NetworkInterface[];

    /**
     * A domain name of the instance. FQDN is defined by the server
     * in the format `<hostname>.<region_id>.internal` when the instance is created.
     * If the hostname were not specified when the instance was created, FQDN would be `<id>.auto.internal`.
     */
    fqdn?: string;

    /**
     * Scheduling policy configuration.
     */
    schedulingPolicy?: SchedulingPolicy;

    /**
     * ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    /**
     * Network Settings
     */
    networkSettings?: NetworkSettings;

    /**
     * Placement policy configuration.
     */
    placementPolicy?: PlacementPolicy;
}

export namespace Instance {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Instance is waiting for resources to be allocated.
         */
        PROVISIONING = 1,

        /**
         * Instance is running normally.
         */
        RUNNING = 2,

        /**
         * Instance is being stopped.
         */
        STOPPING = 3,

        /**
         * Instance stopped.
         */
        STOPPED = 4,

        /**
         * Instance is being started.
         */
        STARTING = 5,

        /**
         * Instance is being restarted.
         */
        RESTARTING = 6,

        /**
         * Instance is being updated.
         */
        UPDATING = 7,

        /**
         * Instance encountered a problem and cannot operate.
         */
        ERROR = 8,

        /**
         * Instance crashed and will be restarted automatically.
         */
        CRASHED = 9,

        /**
         * Instance is being deleted.
         */
        DELETING = 10,
    }
}

export interface Resources {
    /**
     * The amount of memory available to the instance, specified in bytes.
     */
    memory?: Long;

    /**
     * The number of cores available to the instance.
     */
    cores?: Long;

    /**
     * Baseline level of CPU performance with the ability to burst performance above that baseline level.
     * This field sets baseline performance for each core.
     */
    coreFraction?: Long;

    /**
     * The number of GPUs available to the instance.
     */
    gpus?: Long;
}

export interface AttachedDisk {
    /**
     * Access mode to the Disk resource.
     */
    mode?: AttachedDisk.Mode;

    /**
     * Serial number that is reflected into the /dev/disk/by-id/ tree
     * of a Linux operating system running within the instance.
     *
     * This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
     */
    deviceName?: string;

    /**
     * Specifies whether the disk will be auto-deleted when the instance is deleted.
     */
    autoDelete?: boolean;

    /**
     * ID of the disk that is attached to the instance.
     */
    diskId?: string;
}

export namespace AttachedDisk {
    export enum Mode {
        MODE_UNSPECIFIED = 0,

        /**
         * Read-only access.
         */
        READ_ONLY = 1,

        /**
         * Read/Write access.
         */
        READ_WRITE = 2,
    }
}

export interface NetworkInterface {
    /**
     * The index of the network interface, generated by the server, 0,1,2... etc.
     * Currently only one network interface is supported per instance.
     */
    index?: string;

    /**
     * MAC address that is assigned to the network interface.
     */
    macAddress?: string;

    /**
     * ID of the subnet.
     */
    subnetId?: string;

    /**
     * Primary IPv4 address that is assigned to the instance for this network interface.
     */
    primaryV4Address?: PrimaryAddress;

    /**
     * Primary IPv6 address that is assigned to the instance for this network interface. IPv6 not available yet.
     */
    primaryV6Address?: PrimaryAddress;

    /**
     * ID's of security groups attached to the interface
     */
    securityGroupIds?: string[];
}

export interface PrimaryAddress {
    /**
     * An IPv4 internal network address that is assigned to the instance for this network interface.
     */
    address?: string;

    /**
     * One-to-one NAT configuration. If missing, NAT has not been set up.
     */
    oneToOneNat?: OneToOneNat;
}

export interface OneToOneNat {
    /**
     * An external IP address associated with this instance.
     */
    address?: string;

    /**
     * IP version for the external IP address.
     */
    ipVersion?: IpVersion;
}

export enum IpVersion {
    IP_VERSION_UNSPECIFIED = 0,

    /**
     * IPv4 address, for example 192.0.2.235.
     */
    IPV4 = 1,

    /**
     * IPv6 address. Not available yet.
     */
    IPV6 = 2,
}

export interface SchedulingPolicy {
    /**
     * True for short-lived compute instances. For more information, see [Preemptible VMs](/docs/compute/concepts/preemptible-vm).
     */
    preemptible?: boolean;
}

export interface NetworkSettings {
    /**
     * Network Type
     */
    type?: NetworkSettings.Type;
}

export namespace NetworkSettings {
    export enum Type {
        TYPE_UNSPECIFIED = 0,

        /**
         * Standard network.
         */
        STANDARD = 1,

        /**
         * Software accelerated network.
         */
        SOFTWARE_ACCELERATED = 2,

        /**
         * Hardware accelerated network (not available yet, reserved for future use).
         */
        HARDWARE_ACCELERATED = 3,
    }
}

export interface PlacementPolicy {
    /**
     * Placement group ID.
     */
    placementGroupId?: string;
}

/**
 * A set of methods for managing Instance resources.
 */
export class InstanceService {
    constructor(session?: Session);
    /**
     * Returns the specified Instance resource.
     *
     * To get the list of available Instance resources, make a [List] request.
     */
    get(request: GetInstanceRequest): Promise<Instance>;

    /**
     * Retrieves the list of Instance resources in the specified folder.
     */
    list(request: ListInstancesRequest): Promise<ListInstancesResponse>;

    /**
     * Creates an instance in the specified folder.
     * Method starts an asynchronous operation that can be cancelled while it is in progress.
     */
    create(request: CreateInstanceRequest): Promise<operation.Operation>;

    /**
     * Updates the specified instance.
     */
    update(request: UpdateInstanceRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified instance.
     */
    delete(request: DeleteInstanceRequest): Promise<operation.Operation>;

    /**
     * Updates the metadata of the specified instance.
     */
    updateMetadata(
        request: UpdateInstanceMetadataRequest
    ): Promise<operation.Operation>;

    /**
     * Returns the serial port output of the specified Instance resource.
     */
    getSerialPortOutput(
        request: GetInstanceSerialPortOutputRequest
    ): Promise<GetInstanceSerialPortOutputResponse>;

    /**
     * Stops the running instance.
     *
     * You can start the instance later using the [InstanceService.Start] method.
     */
    stop(request: StopInstanceRequest): Promise<operation.Operation>;

    /**
     * Starts the stopped instance.
     */
    start(request: StartInstanceRequest): Promise<operation.Operation>;

    /**
     * Restarts the running instance.
     */
    restart(request: RestartInstanceRequest): Promise<operation.Operation>;

    /**
     * Attaches the disk to the instance.
     */
    attachDisk(
        request: AttachInstanceDiskRequest
    ): Promise<operation.Operation>;

    /**
     * Detaches the disk from the instance.
     */
    detachDisk(
        request: DetachInstanceDiskRequest
    ): Promise<operation.Operation>;

    addOneToOneNat(
        request: AddInstanceOneToOneNatRequest
    ): Promise<operation.Operation>;

    removeOneToOneNat(
        request: RemoveInstanceOneToOneNatRequest
    ): Promise<operation.Operation>;

    updateNetworkInterface(
        request: UpdateNetworkInterfaceRequest
    ): Promise<operation.Operation>;

    /**
     * Lists operations for the specified instance.
     */
    listOperations(
        request: ListInstanceOperationsRequest
    ): Promise<ListInstanceOperationsResponse>;
}

export enum InstanceView {
    /**
     * Doesn't include the metadata of the instance in the server response.
     */
    BASIC = 0,

    /**
     * Returns the metadata of the instance in the server response.
     */
    FULL = 1,
}

export interface GetInstanceRequest {
    /**
     * ID of the Instance resource to return.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;

    /**
     * Defines which information about the Instance resource should be returned in the server response.
     */
    view?: InstanceView;
}

export interface ListInstancesRequest {
    /**
     * ID of the Folder to list instances in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListInstancesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListInstancesResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on the [Instance.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Must be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
     */
    filter?: string;
}

export interface ListInstancesResponse {
    /**
     * List of Instance resources.
     */
    instances?: Instance[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListInstancesRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListInstancesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateInstanceRequest {
    /**
     * ID of the folder to create an instance in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * Name of the instance.
     */
    name?: string;

    /**
     * Description of the instance.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the availability zone where the instance resides.
     * To get a list of available zones, use the [yandex.cloud.compute.v1.ZoneService.List] request
     */
    zoneId: string;

    /**
     * ID of the hardware platform configuration for the instance.
     * This field affects the available values in [resources_spec] field.
     *
     * Platforms allows you to create various types of instances: with a large amount of memory,
     * with a large number of cores, with a burstable performance.
     * For more information, see [Platforms](/docs/compute/concepts/vm-platforms).
     */
    platformId: string;

    /**
     * Computing resources of the instance, such as the amount of memory and number of cores.
     * To get a list of available values, see [Levels of core performance](/docs/compute/concepts/performance-levels).
     */
    resourcesSpec: ResourcesSpec;

    /**
     * The metadata `key:value` pairs that will be assigned to this instance. This includes custom metadata and predefined keys.
     * The total size of all keys and values must be less than 512 KB.
     *
     * Values are free-form strings, and only have meaning as interpreted by the programs which configure the instance.
     * The values must be 256 KB or less.
     *
     * For example, you may use the metadata in order to provide your public SSH key to the instance.
     * For more information, see [Metadata](/docs/compute/concepts/vm-metadata).
     */
    metadata?: { [s: string]: string };

    /**
     * Boot disk to attach to the instance.
     */
    bootDiskSpec: AttachedDiskSpec;

    /**
     * Array of secondary disks to attach to the instance.
     */
    secondaryDiskSpecs?: AttachedDiskSpec[];

    /**
     * Network configuration for the instance. Specifies how the network interface is configured
     * to interact with other services on the internal network and on the internet.
     * Currently only one network interface is supported per instance.
     */
    networkInterfaceSpecs?: NetworkInterfaceSpec[];

    /**
     * Host name for the instance.
     * This field is used to generate the [yandex.cloud.compute.v1.Instance.fqdn] value.
     * The host name must be unique within the network and region.
     * If not specified, the host name will be equal to [yandex.cloud.compute.v1.Instance.id] of the instance
     * and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
     */
    hostname?: string;

    /**
     * Scheduling policy configuration.
     */
    schedulingPolicy?: SchedulingPolicy;

    /**
     * ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    /**
     * Network settings.
     */
    networkSettings?: NetworkSettings;

    /**
     * Placement policy configuration.
     */
    placementPolicy?: PlacementPolicy;
}

export interface CreateInstanceMetadata {
    /**
     * ID of the instance that is being created.
     */
    instanceId?: string;
}

export interface UpdateInstanceRequest {
    /**
     * ID of the Instance resource to update.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;

    /**
     * Field mask that specifies which fields of the Instance resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the instance.
     */
    name?: string;

    /**
     * Description of the instance.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };

    /**
     * ID of the hardware platform configuration for the instance.
     * This field affects the available values in [resources_spec] field.
     *
     * Platforms allows you to create various types of instances: with a large amount of memory,
     * with a large number of cores, with a burstable performance.
     * For more information, see [Platforms](/docs/compute/concepts/vm-platforms).
     */
    platformId?: string;

    /**
     * Computing resources of the instance, such as the amount of memory and number of cores.
     * To get a list of available values, see [Levels of core performance](/docs/compute/concepts/performance-levels).
     */
    resourcesSpec?: ResourcesSpec;

    /**
     * The metadata `key:value` pairs that will be assigned to this instance. This includes custom metadata and predefined keys.
     * The total size of all keys and values must be less than 512 KB.
     *
     * Existing set of `metadata` is completely replaced by the provided set.
     *
     * Values are free-form strings, and only have meaning as interpreted by the programs which configure the instance.
     * The values must be 256 KB or less.
     *
     * For example, you may use the metadata in order to provide your public SSH key to the instance.
     * For more information, see [Metadata](/docs/compute/concepts/vm-metadata).
     */
    metadata?: { [s: string]: string };

    /**
     * ID of the service account to use for [authentication inside the instance](/docs/compute/operations/vm-connect/auth-inside-vm).
     * To get the service account ID, use a [yandex.cloud.iam.v1.ServiceAccountService.List] request.
     */
    serviceAccountId?: string;

    /**
     * Network settings.
     */
    networkSettings?: NetworkSettings;

    /**
     * Placement policy configuration.
     */
    placementPolicy?: PlacementPolicy;
}

export interface UpdateInstanceMetadata {
    /**
     * ID of the Instance resource that is being updated.
     */
    instanceId?: string;
}

export interface DeleteInstanceRequest {
    /**
     * ID of the instance to delete.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;
}

export interface DeleteInstanceMetadata {
    /**
     * ID of the instance that is being deleted.
     */
    instanceId?: string;
}

export interface UpdateInstanceMetadataRequest {
    /**
     * ID of the instance that is being updated.
     */
    instanceId?: string;

    /**
     * List of keys to be deleted.
     */
    delete?: string[];

    /**
     * The metadata `key:value` pairs that will be added or updated to this instance.
     */
    upsert?: { [s: string]: string };
}

export interface UpdateInstanceMetadataMetadata {
    /**
     * ID of the instance that is being updated.
     */
    instanceId?: string;
}

export interface GetInstanceSerialPortOutputRequest {
    /**
     * ID of the instance to return the serial port output for.
     */
    instanceId: string;

    /**
     * Serial port to retrieve data from. The default is 1.
     */
    port?: Long;
}

export interface GetInstanceSerialPortOutputResponse {
    /**
     * The contents of the serial port output, starting from the time when the instance
     * started to boot.
     */
    contents?: string;
}

export interface StopInstanceRequest {
    /**
     * ID of the instance to stop.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;
}

export interface StopInstanceMetadata {
    /**
     * ID of the instance that is being deleted.
     */
    instanceId?: string;
}

export interface StartInstanceRequest {
    /**
     * ID of the instance to start.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;
}

export interface StartInstanceMetadata {
    /**
     * ID of the instance.
     */
    instanceId?: string;
}

export interface RestartInstanceRequest {
    /**
     * ID of the instance to restart.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;
}

export interface RestartInstanceMetadata {
    /**
     * ID of the instance.
     */
    instanceId?: string;
}

export interface AttachInstanceDiskRequest {
    /**
     * ID of the instance to attach the disk to.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;

    /**
     * Disk that should be attached.
     */
    attachedDiskSpec: AttachedDiskSpec;
}

export interface AttachInstanceDiskMetadata {
    /**
     * ID of the instance.
     */
    instanceId?: string;

    /**
     * ID of the disk.
     */
    diskId?: string;
}

export interface DetachInstanceDiskRequest {
    /**
     * ID of the instance to detach the disk from.
     * To get the instance ID, use a [InstanceService.List] request.
     */
    instanceId: string;

    /**
     * ID of the disk that should be detached.
     */
    diskId?: string;

    /**
     * Serial number of the disk that should be detached. This value is reflected into the /dev/disk/by-id/ tree
     * of a Linux operating system running within the instance.
     */
    deviceName?: string;
}

export interface DetachInstanceDiskMetadata {
    /**
     * ID of the instance.
     */
    instanceId?: string;

    /**
     * ID of the disk.
     */
    diskId?: string;
}

export interface AddInstanceOneToOneNatRequest {
    instanceId?: string;

    networkInterfaceIndex?: string;

    /**
     * optional
     */
    internalAddress?: string;

    /**
     * optional
     */
    oneToOneNatSpec?: OneToOneNatSpec;
}

export interface AddInstanceOneToOneNatMetadata {
    instanceId?: string;
}

export interface RemoveInstanceOneToOneNatRequest {
    instanceId?: string;

    networkInterfaceIndex?: string;

    /**
     * optional
     */
    internalAddress?: string;
}

export interface RemoveInstanceOneToOneNatMetadata {
    instanceId?: string;
}

export interface UpdateNetworkInterfaceRequest {
    instanceId: string;

    networkInterfaceIndex: string;

    updateMask?: protobuf.FieldMask;

    securityGroupIds?: string[];
}

export interface UpdateNetworkInterfaceMetadata {
    instanceId?: string;

    networkInterfaceIndex?: string;
}

export interface ListInstanceOperationsRequest {
    /**
     * ID of the Instance resource to list operations for.
     */
    instanceId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListInstanceOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListInstanceOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListInstanceOperationsResponse {
    /**
     * List of operations for the specified instance.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListInstanceOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListInstanceOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ResourcesSpec {
    /**
     * The amount of memory available to the instance, specified in bytes.
     */
    memory: Long;

    /**
     * The number of cores available to the instance.
     */
    cores: Long;

    /**
     * Baseline level of CPU performance with the ability to burst performance above that baseline level.
     * This field sets baseline performance for each core.
     *
     * For example, if you need only 5% of the CPU performance, you can set core_fraction=5.
     * For more information, see [Levels of core performance](/docs/compute/concepts/performance-levels).
     */
    coreFraction?: Long;

    /**
     * The number of GPUs available to the instance.
     */
    gpus?: Long;
}

export interface AttachedDiskSpec {
    /**
     * The mode in which to attach this disk.
     */
    mode?: AttachedDiskSpec.Mode;

    /**
     * Specifies a unique serial number of your choice that is reflected into the /dev/disk/by-id/ tree
     * of a Linux operating system running within the instance.
     *
     * This value can be used to reference the device for mounting, resizing, and so on, from within the instance.
     * If not specified, a random value will be generated.
     */
    deviceName?: string;

    /**
     * Specifies whether the disk will be auto-deleted when the instance is deleted.
     */
    autoDelete?: boolean;

    /**
     * Disk specification.
     */
    diskSpec?: AttachedDiskSpec.DiskSpec;

    /**
     * ID of the disk that should be attached.
     */
    diskId?: string;
}

export namespace AttachedDiskSpec {
    export enum Mode {
        MODE_UNSPECIFIED = 0,

        /**
         * Read-only access.
         */
        READ_ONLY = 1,

        /**
         * Read/Write access. Default value.
         */
        READ_WRITE = 2,
    }

    export interface DiskSpec {
        /**
         * Name of the disk.
         */
        name?: string;

        /**
         * Description of the disk.
         */
        description?: string;

        /**
         * ID of the disk type.
         * To get a list of available disk types, use the [yandex.cloud.compute.v1.DiskTypeService.List] request.
         */
        typeId?: string;

        /**
         * Size of the disk, specified in bytes.
         */
        size: Long;

        /**
         * ID of the image to create the disk from.
         */
        imageId?: string;

        /**
         * ID of the snapshot to restore the disk from.
         */
        snapshotId?: string;
    }
}

export interface NetworkInterfaceSpec {
    /**
     * ID of the subnet.
     */
    subnetId: string;

    /**
     * Primary IPv4 address that will be assigned to the instance for this network interface.
     */
    primaryV4AddressSpec?: PrimaryAddressSpec;

    /**
     * Primary IPv6 address that will be assigned to the instance for this network interface. IPv6 not available yet.
     */
    primaryV6AddressSpec?: PrimaryAddressSpec;

    /**
     * ID's of security groups attached to the interface
     */
    securityGroupIds?: string[];
}

export interface PrimaryAddressSpec {
    /**
     * An IPv4 internal network address that is assigned to the instance for this network interface.
     * If not specified by the user, an unused internal IP is assigned by the system.
     */
    address?: string;

    /**
     * An external IP address configuration.
     * If not specified, then this instance will have no external internet access.
     */
    oneToOneNatSpec?: OneToOneNatSpec;
}

export interface OneToOneNatSpec {
    /**
     * External IP address version.
     */
    ipVersion?: IpVersion;

    /**
     * only if address unspecified
     */
    address?: string;
}

export interface PlacementGroup {
    /**
     * ID of the placement group. Generated at creation time.
     */
    id?: string;

    /**
     * ID of the folder that the placement group belongs to.
     */
    folderId?: string;

    /**
     * Creation timestamp.
     */
    createdAt?: protobuf.Timestamp;

    /**
     * Name of the placement group.
     * The name is unique within the folder.
     */
    name?: string;

    /**
     * Description of the placement group. 0-256 characters long.
     */
    description?: string;

    /**
     * Placement group labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Anti-affinity placement strategy (`spread`). Instances are distributed
     * over distinct failure domains.
     */
    spreadPlacementStrategy?: SpreadPlacementStrategy;
}

/**
 * This is an empty structure that must be passed to explicitly
 * specify the required placement strategy.
 */
export interface SpreadPlacementStrategy {}

/**
 * A set of methods for managing placement groups.
 */
export class PlacementGroupService {
    constructor(session?: Session);
    /**
     * Returns the specified placement group.
     *
     * To get the list of all available placement groups, make a [List] request.
     */
    get(request: GetPlacementGroupRequest): Promise<PlacementGroup>;

    /**
     * Retrieves the list of placement groups in the specified folder.
     */
    list(
        request: ListPlacementGroupsRequest
    ): Promise<ListPlacementGroupsResponse>;

    /**
     * Creates a placement group in the specified folder.
     */
    create(request: CreatePlacementGroupRequest): Promise<operation.Operation>;

    /**
     * Updates the specified placement group.
     */
    update(request: UpdatePlacementGroupRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified placement group.
     */
    delete(request: DeletePlacementGroupRequest): Promise<operation.Operation>;

    /**
     * Lists instances for the specified placement group.
     */
    listInstances(
        request: ListPlacementGroupInstancesRequest
    ): Promise<ListPlacementGroupInstancesResponse>;

    /**
     * Lists operations for the specified placement group.
     */
    listOperations(
        request: ListPlacementGroupOperationsRequest
    ): Promise<ListPlacementGroupOperationsResponse>;
}

export interface GetPlacementGroupRequest {
    /**
     * ID of the placement group to return.
     *
     * To get a placement group ID make a [PlacementGroupService.List] request.
     */
    placementGroupId?: string;
}

export interface ListPlacementGroupsRequest {
    /**
     * ID of the folder to list placement groups in.
     *
     * To get the folder ID make a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId?: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListPlacementGroupsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListPlacementGroupsResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * Currently you can use filtering only on the [PlacementGroup.name] field.
     */
    filter?: string;
}

export interface ListPlacementGroupsResponse {
    /**
     * Lists placement groups in the specified folder.
     */
    placementGroups?: PlacementGroup[];

    /**
     * Token for getting the next page of the list. If the number of results is greater than
     * the specified [ListPlacementGroupsRequest.page_size], use `next_page_token` as the value
     * for the [ListPlacementGroupsRequest.page_token] parameter in the next list request.
     *
     * Each subsequent page will have its own `next_page_token` to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreatePlacementGroupRequest {
    /**
     * ID of the folder to create a placement group in.
     *
     * To get a folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId?: string;

    /**
     * Name of the placement group.
     */
    name?: string;

    /**
     * Description of the placement group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };

    /**
     * Anti-affinity placement strategy (`spread`). Instances are distributed over distinct failure domains.
     */
    spreadPlacementStrategy?: SpreadPlacementStrategy;
}

export interface CreatePlacementGroupMetadata {
    /**
     * ID of the placement group that is being created.
     */
    placementGroupId?: string;
}

export interface UpdatePlacementGroupRequest {
    /**
     * ID of the placement group to update.
     *
     * To get the placement group ID, use an [PlacementGroupService.List] request.
     */
    placementGroupId?: string;

    /**
     * Field mask that specifies which fields of the PlacementGroup resource should be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the placement group.
     */
    name?: string;

    /**
     * Description of the placement group.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * The existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };
}

export interface UpdatePlacementGroupMetadata {
    /**
     * ID of the placement group that is being updated.
     */
    placementGroupId?: string;
}

export interface DeletePlacementGroupRequest {
    /**
     * ID of the placement group to delete.
     *
     * To get the placement group ID, use [PlacementGroupService.List] request.
     */
    placementGroupId?: string;
}

export interface DeletePlacementGroupMetadata {
    /**
     * ID of the placement group that is being deleted.
     */
    placementGroupId?: string;
}

export interface ListPlacementGroupInstancesRequest {
    /**
     * ID of the placement group to list instances for.
     *
     * To get the placement group ID, use [PlacementGroupService.List] request.
     */
    placementGroupId?: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListPlacementGroupInstancesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results,
     * set [page_token] to the [ListPlacementGroupInstancesResponse.next_page_token]
     * returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListPlacementGroupInstancesResponse {
    /**
     * Lists instances for the specified placement group.
     */
    instances?: Instance[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is more than [ListPlacementGroupInstancesRequest.page_size], use
     * [next_page_token] as the value
     * for the [ListPlacementGroupInstancesRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface ListPlacementGroupOperationsRequest {
    /**
     * ID of the placement group to list operations for.
     *
     * To get the placement group ID, use [PlacementGroupService.List] request.
     */
    placementGroupId?: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListPlacementGroupOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListPlacementGroupOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListPlacementGroupOperationsResponse {
    /**
     * List of operations for the specified placement group.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListPlacementGroupOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListPlacementGroupOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

/**
 * A Snapshot resource. For more information, see [Snapshots](/docs/compute/concepts/snapshot).
 */
export interface Snapshot {
    /**
     * ID of the snapshot.
     */
    id?: string;

    /**
     * ID of the folder that the snapshot belongs to.
     */
    folderId?: string;

    createdAt?: protobuf.Timestamp;

    /**
     * Name of the snapshot. 1-63 characters long.
     */
    name?: string;

    /**
     * Description of the snapshot. 0-256 characters long.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs. Maximum of 64 per resource.
     */
    labels?: { [s: string]: string };

    /**
     * Size of the snapshot, specified in bytes.
     */
    storageSize?: Long;

    /**
     * Size of the disk when the snapshot was created, specified in bytes.
     */
    diskSize?: Long;

    /**
     * License IDs that indicate which licenses are attached to this resource.
     * License IDs are used to calculate additional charges for the use of the virtual machine.
     *
     * The correct license ID is generated by Yandex.Cloud. IDs are inherited by new resources created from this resource.
     *
     * If you know the license IDs, specify them when you create the image.
     * For example, if you create a disk image using a third-party utility and load it into Yandex Object Storage, the license IDs will be lost.
     * You can specify them in the [yandex.cloud.compute.v1.ImageService.Create] request.
     */
    productIds?: string[];

    /**
     * Current status of the snapshot.
     */
    status?: Snapshot.Status;

    /**
     * ID of the source disk used to create this snapshot.
     */
    sourceDiskId?: string;
}

export namespace Snapshot {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Snapshot is being created.
         */
        CREATING = 1,

        /**
         * Snapshot is ready to use.
         */
        READY = 2,

        /**
         * Snapshot encountered a problem and cannot operate.
         */
        ERROR = 3,

        /**
         * Snapshot is being deleted.
         */
        DELETING = 4,
    }
}

/**
 * A set of methods for managing Snapshot resources.
 */
export class SnapshotService {
    constructor(session?: Session);
    /**
     * Returns the specified Snapshot resource.
     *
     * To get the list of available Snapshot resources, make a [List] request.
     */
    get(request: GetSnapshotRequest): Promise<Snapshot>;

    /**
     * Retrieves the list of Snapshot resources in the specified folder.
     */
    list(request: ListSnapshotsRequest): Promise<ListSnapshotsResponse>;

    /**
     * Creates a snapshot of the specified disk.
     */
    create(request: CreateSnapshotRequest): Promise<operation.Operation>;

    /**
     * Updates the specified snapshot.
     *
     * Values of omitted parameters are not changed.
     */
    update(request: UpdateSnapshotRequest): Promise<operation.Operation>;

    /**
     * Deletes the specified snapshot.
     *
     * Deleting a snapshot removes its data permanently and is irreversible.
     */
    delete(request: DeleteSnapshotRequest): Promise<operation.Operation>;

    /**
     * Lists operations for the specified snapshot.
     */
    listOperations(
        request: ListSnapshotOperationsRequest
    ): Promise<ListSnapshotOperationsResponse>;
}

export interface GetSnapshotRequest {
    /**
     * ID of the Snapshot resource to return.
     * To get the snapshot ID, use a [SnapshotService.List] request.
     */
    snapshotId: string;
}

export interface ListSnapshotsRequest {
    /**
     * ID of the folder to list snapshots in.
     * To get the folder ID, use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListSnapshotsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListSnapshotsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;

    /**
     * A filter expression that filters resources listed in the response.
     * The expression must specify:
     * 1. The field name. Currently you can use filtering only on the [Snapshot.name] field.
     * 2. An operator. Can be either `=` or `!=` for single values, `IN` or `NOT IN` for lists of values.
     * 3. The value. Мust be 3-63 characters long and match the regular expression `^[a-z]([-a-z0-9]{,61}[a-z0-9])?$`.
     */
    filter?: string;
}

export interface ListSnapshotsResponse {
    /**
     * List of snapshots.
     */
    snapshots?: Snapshot[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListSnapshotsRequest.page_size], use
     * the [next_page_token] as the value
     * for the [ListSnapshotsRequest.page_token] query parameter
     * in the next list request. Each subsequent list request will have its own
     * [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface CreateSnapshotRequest {
    /**
     * ID of the folder to create a snapshot in.
     * To get the folder ID use a [yandex.cloud.resourcemanager.v1.FolderService.List] request.
     */
    folderId: string;

    /**
     * ID of the disk to create the snapshot from.
     * To get the disk ID use a [yandex.cloud.compute.v1.DiskService.List] request.
     */
    diskId: string;

    /**
     * Name of the snapshot.
     */
    name?: string;

    /**
     * Description of the snapshot.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     */
    labels?: { [s: string]: string };
}

export interface CreateSnapshotMetadata {
    /**
     * ID of the snapshot that is being created.
     */
    snapshotId?: string;

    /**
     * ID of the source disk used to create this snapshot.
     */
    diskId?: string;
}

export interface UpdateSnapshotRequest {
    /**
     * ID of the Snapshot resource to update.
     * To get the snapshot ID use a [SnapshotService.List] request.
     */
    snapshotId: string;

    /**
     * Field mask that specifies which fields of the Snapshot resource are going to be updated.
     */
    updateMask?: protobuf.FieldMask;

    /**
     * Name of the snapshot.
     */
    name?: string;

    /**
     * Description of the snapshot.
     */
    description?: string;

    /**
     * Resource labels as `key:value` pairs.
     *
     * Existing set of `labels` is completely replaced by the provided set.
     */
    labels?: { [s: string]: string };
}

export interface UpdateSnapshotMetadata {
    /**
     * ID of the Snapshot resource that is being updated.
     */
    snapshotId?: string;
}

export interface DeleteSnapshotRequest {
    /**
     * ID of the snapshot to delete.
     * To get the snapshot ID, use a [SnapshotService.List] request.
     */
    snapshotId: string;
}

export interface DeleteSnapshotMetadata {
    /**
     * ID of the snapshot that is being deleted.
     */
    snapshotId?: string;
}

export interface ListSnapshotOperationsRequest {
    /**
     * ID of the Snapshot resource to list operations for.
     */
    snapshotId: string;

    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size], the service returns a [ListSnapshotOperationsResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListSnapshotOperationsResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListSnapshotOperationsResponse {
    /**
     * List of operations for the specified snapshot.
     */
    operations?: operation.Operation[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListSnapshotOperationsRequest.page_size], use the [next_page_token] as the value
     * for the [ListSnapshotOperationsRequest.page_token] query parameter in the next list request.
     * Each subsequent list request will have its own [next_page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

/**
 * Availability zone. For more information, see [Availability zones](/docs/overview/concepts/geo-scope).
 */
export interface Zone {
    /**
     * ID of the zone.
     */
    id?: string;

    /**
     * ID of the region.
     */
    regionId?: string;

    /**
     * Status of the zone.
     */
    status?: Zone.Status;
}

export namespace Zone {
    export enum Status {
        STATUS_UNSPECIFIED = 0,

        /**
         * Zone is available. You can access the resources allocated in this zone.
         */
        UP = 1,

        /**
         * Zone is not available.
         */
        DOWN = 2,
    }
}

/**
 * A set of methods to retrieve information about availability zones.
 */
export class ZoneService {
    constructor(session?: Session);
    /**
     * Returns the information about the specified availability zone.
     *
     * To get the list of availability zones, make a [List] request.
     */
    get(request: GetZoneRequest): Promise<Zone>;

    /**
     * Retrieves the list of availability zones.
     */
    list(request: ListZonesRequest): Promise<ListZonesResponse>;
}

export interface ListZonesRequest {
    /**
     * The maximum number of results per page to return. If the number of available
     * results is larger than [page_size],
     * the service returns a [ListZonesResponse.next_page_token]
     * that can be used to get the next page of results in subsequent list requests.
     */
    pageSize?: Long;

    /**
     * Page token. To get the next page of results, set [page_token] to the
     * [ListZonesResponse.next_page_token] returned by a previous list request.
     */
    pageToken?: string;
}

export interface ListZonesResponse {
    /**
     * List of availability zones.
     */
    zones?: Zone[];

    /**
     * This token allows you to get the next page of results for list requests. If the number of results
     * is larger than [ListZonesRequest.page_size], use
     * the [ListZonesRequest.page_token] as the value
     * for the [ListZonesRequest.page_token] query parameter
     * in the next list request. Subsequent list requests will have their own
     * [ListZonesRequest.page_token] to continue paging through the results.
     */
    nextPageToken?: string;
}

export interface GetZoneRequest {
    /**
     * ID of the availability zone to return information about.
     */
    zoneId: string;
}
